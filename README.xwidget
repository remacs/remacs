* Xwidgets

This is an experimental branch to enable embedding of GTK widgets
inside an Emacs window. The Emacs abstraction is called an Xwidget,
for eXternal widget, and also in reference to the Xembed protocoll.

There is a demo file called xwidget-test.el which shows some of the
possibilities. There are some screnshots at the emacswiki.

Currently its possible to insert buttons, sliders, and xembed widgets
in the buffer. It works similar to the support for images in Emacs.
Adding more types of widgets should be fairly straightforward, but
will require adapter code for each type.

A difference from images is that xwidgets live their own life. You
create them with an api, get a reference, and tie them to a particular
buffer with a display spec. Also, xwidgets exists in only one copy,
where a plain image can be shown in several windows. The xwidget code
tries to handle this by essentialy making a screen capture of the
widget and displaying those in the non-active windows, and the live
widget in the active window. The current snapshot code doesnt work if
the live xwidget is off-screen. This seems to be solveable by using
the XComposite interface, but that doesnt currently work.

The current state is that one window, one frame, showing many xwidgets
is a nice demo. One frame, many windows, will have lots of display
glitches. Many frames, many windows, will work even worse.


* Brief overview of how xwidgets work
Xwidgets work in one way like images in Emacs. You bind a display spec very
similar to an image display spec to buffer contents. The display engine will
notice the display spec and try to display the xwidget there. The display engine
prepares space at the right place for the xwidget and so on for free, as long as
we provide proper sizes and so on back to the redisplay engine.

** Issues
The problem is that Emacs cant actually draw the widgets, as it can with
images. Emacs must notify GTK about where the widgets should be, and how they
should be clipped and so on, and this information must be given to GTK
synchonous with Emacs display changes. Ok, so why is that difficult then?

- How do we know when a widget is NOT to be drawn? The only way I found so far
  is having a flag for each xwdiget, that is reset before a redisplay. When an
  xwidget is encountered during display, the flag is set. After redisplay,
  iterate all xwidgets and hide those which hasnt been displayed. 

- In the general case, there can only be one xwidget, and several views of
  it. There is one live view, and several phantom views. The live view is defined
  to be in the currently selected window. All other views are phantom views. 

  Even this simple rule is difficult to implement in practice because Emacs
  display is clever and optimized. It is often difficult to know that a xwdiget
  hasnt actually been displayed after a redisplay.

- phantom views of xwidgets are thankfully not so hard because gtk
  supports snapshoting of many widget types. Snapshoting doesnt seem
  to work if the live widget is offscreen. This might be solvable with
  xcomposite, but attempts have so far failed.

- The gtk socket type for embedding external applications is desirable
  but presents a lot of difficulties of its own. One difficulty is
  deciding which input events to forward, and when and how to do it.

- The case of showing an xwidget in several frames is not solved at all
  currently. This would mean moving the live xwidget between frames when the
  selected window moves. The gtk widget will need to be reparented between
  windows, which seems fragile. 

** placement and clipping
the entire emacs frame is a gtk window. we use the fixed layout
manager to place xwidgets on the frame. coordinates are supplied by
the emacs display engine. widgets are placed inside an intermediate
window, called the widgetwindow. the widgetwindows are placed on the
emacs frame.

this way was chosen to simplify clipping of the widgets against emacs
window borders.

** xwidget phantom views in particular
The general aproach so far has been to have a "live" xwidget moved
around in the emacs window. when the selected window changes, the live
xwidget is moved there. the possibly other views of the xwidget are
called "phantoms" and are snapshoted from the live xwidget.

This turned out to be difficult and a lot of different aproaches has
been tried. The current, somewhat promising, aproach is to enable
composition for the xwidgets gtk widget peer. This enables renedering
of the widget to offscreen backing store. snapshoting then becomes
more robus, because otherwise snapshoting is dependent on the live
xwidget being on-screen, which isnt necesarily the case.

on the other hand, compositing introduces other issues. the live
xwidget isnt drawn automatically at all any more, so we need our own
expose handler to deal with drawing. this in turn enables us to toy
with transparency and such.

** different strategies
Integrating toolkit widgets(gtk in this case) and the emacs display
engine is more difficult than your plain average gui application, and
different strategies has been tested and will continue to be tested.

There will probably always be a distinction between live xwidgets and
phantom xwidgets. how this distinction is realized has and will
change.

- the first aproach was to have the live xwidget on-screen, and move
  them about. the phantoms were generated by snapshoting the live
  xwidget. 

the drawback of that aproach was that the gtk toolkit is admirably
lazy and doesnt draw the widget if its not actualy shown, meaning that
the snapshots for the phantoms will show garbage.

- the second aproach was to use composition support. that tells gtk
  that the widget should be drawn in an off-screen buffer and drawn on
  screen by the application.

this has the primary advantage that the snapshot is always
available, and enables the possibility of more eye-candy like drawing
live and phantom widgets in different colors.

the drawback is that its our own responsibility to handle drawing,
which puts more of the display optimization burden on us.

this is the currently tried aproach and it works so-so at the moment.

- another aproach is to have both live and phantom widgets drawn
  on-screen by proxy gtk objects. the live xwidget will be entirely
  handled in an off-screen window, and the proxy objects will redirect
  events there.

This aproach seems promising, but complicated.

- combine on-screen and off-screen aproaches. maybe composition is the
  way to go for most cases, but on-screen xembeding is the way to go
  for particular special cases, like showing video in a
  window. off-screen rendering and whatnot, is not efficient in that
  particular case, and the user will simply have to accept that the
  phantom of a video widget isnt particularily beautiful.

* ToDo:s

** DONE Examine using XComposite rather than GTK off-screen
  rendering. This would make xembed widgets work much better. This
  would probably be rathter difficult, but could open up other
  interesting possibilities for Emacs. There is an early attempt in
  xwidget.c, but the X call to redirect to offscreen rendering fails
  for unknown reasons.

  the attempt was further worked on, and the xlib calls replaced with
  gdk calls, this works better.

** TODO  make the keyboard event code propagation code work. There is an attempt 
to provide an api to send keyboard events to an xwidget, but it doesnt currently
work very well.

** DONE remove the special-case for when the minibuffer is
  active.  I added some code to reduce the annoying problem display artefacts
  when making the minibuffer the selected window. This made xwidgets in the
  buffer go grey or black whenever one did m-x to activate the minibuffer. The
  coded tried to handle the minibuffer as a special case. That simply wasnt a
  good idea. Special-casing will never work properly. It is much better to spend
  time finding solutions that work acceptably in the general case.

** DONE disable emacs cursor drawing on top of an active xwidget. 
  This ought to be rather simple and should improve the visuals a lot.
  

** TODO  figure out what to do with the multiple frames case. 
I havent spent any time at all on this.

** TODO  improve the xwidgets programming interface so its less of
  hand-waving affair. This shouldnt be too hard, but I have deliberatley not
spent any time on it, since getting the visuals right is much
harder. Anyway, I sort of think the interface should be somewhat like
it is, except symbols is used instead of integers.

** TODO  more documentation
There should be user docs, and xwidget contributor docs. The current README
is all contributor docs there is now, apart from the code.

** TODO  look into more ways of displaying xwidgets, like binding them to a
window rather than a point in a buffer. This was suggested by Chidong.
This would be a useful addition to Emacs in itself, and would avoid nearly all 
display issues. I still think the general case is more interesting, but this
special case should also be added. The xwidget would then be bound to
replace the view of a particular window, and it would only show in
that window.

