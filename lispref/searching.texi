@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999
@c   Free Software Foundation, Inc. 
@c See the file elisp.texi for copying conditions.
@setfilename ../info/searching
@node Searching and Matching, Syntax Tables, Non-ASCII Characters, Top
@chapter Searching and Matching
@cindex searching

  GNU Emacs provides two ways to search through a buffer for specified
text: exact string searches and regular expression searches.  After a
regular expression search, you can examine the @dfn{match data} to
determine which text matched the whole regular expression or various
portions of it.

@menu
* String Search::         Search for an exact match.
* Regular Expressions::   Describing classes of strings.
* Regexp Search::         Searching for a match for a regexp.
* POSIX Regexps::         Searching POSIX-style for the longest match.
* Search and Replace::	  Internals of @code{query-replace}.
* Match Data::            Finding out which part of the text matched
                            various parts of a regexp, after regexp search.
* Searching and Case::    Case-independent or case-significant searching.
* Standard Regexps::      Useful regexps for finding sentences, pages,...
@end menu

  The @samp{skip-chars@dots{}} functions also perform a kind of searching.
@xref{Skipping Characters}.

@node String Search
@section Searching for Strings
@cindex string search

  These are the primitive functions for searching through the text in a
buffer.  They are meant for use in programs, but you may call them
interactively.  If you do so, they prompt for the search string; the
arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat}
is 1.

  These search functions convert the search string to multibyte if the
buffer is multibyte; they convert the search string to unibyte if the
buffer is unibyte.  @xref{Text Representations}.

@deffn Command search-forward string &optional limit noerror repeat
This function searches forward from point for an exact match for
@var{string}.  If successful, it sets point to the end of the occurrence
found, and returns the new value of point.  If no match is found, the
value and side effects depend on @var{noerror} (see below).
@c Emacs 19 feature

In the following example, point is initially at the beginning of the
line.  Then @code{(search-forward "fox")} moves point after the last
letter of @samp{fox}:

@example
@group
---------- Buffer: foo ----------
@point{}The quick brown fox jumped over the lazy dog.
---------- Buffer: foo ----------
@end group

@group
(search-forward "fox")
     @result{} 20

---------- Buffer: foo ----------
The quick brown fox@point{} jumped over the lazy dog.
---------- Buffer: foo ----------
@end group
@end example

The argument @var{limit} specifies the upper bound to the search.  (It
must be a position in the current buffer.)  No match extending after
that position is accepted.  If @var{limit} is omitted or @code{nil}, it
defaults to the end of the accessible portion of the buffer.

@kindex search-failed
What happens when the search fails depends on the value of
@var{noerror}.  If @var{noerror} is @code{nil}, a @code{search-failed}
error is signaled.  If @var{noerror} is @code{t}, @code{search-forward}
returns @code{nil} and does nothing.  If @var{noerror} is neither
@code{nil} nor @code{t}, then @code{search-forward} moves point to the
upper bound and returns @code{nil}.  (It would be more consistent now to
return the new position of point in that case, but some existing
programs may depend on a value of @code{nil}.)

If @var{repeat} is supplied (it must be a positive number), then the
search is repeated that many times (each time starting at the end of the
previous time's match).  If these successive searches succeed, the
function succeeds, moving point and returning its new value.  Otherwise
the search fails, leaving point where it started.
@end deffn

@deffn Command search-backward string &optional limit noerror repeat
This function searches backward from point for @var{string}.  It is
just like @code{search-forward} except that it searches backwards and
leaves point at the beginning of the match.
@end deffn

@deffn Command word-search-forward string &optional limit noerror repeat
@cindex word search
This function searches forward from point for a ``word'' match for
@var{string}.  If it finds a match, it sets point to the end of the
match found, and returns the new value of point.
@c Emacs 19 feature

Word matching regards @var{string} as a sequence of words, disregarding
punctuation that separates them.  It searches the buffer for the same
sequence of words.  Each word must be distinct in the buffer (searching
for the word @samp{ball} does not match the word @samp{balls}), but the
details of punctuation and spacing are ignored (searching for @samp{ball
boy} does match @samp{ball.  Boy!}).

In this example, point is initially at the beginning of the buffer; the
search leaves it between the @samp{y} and the @samp{!}.

@example
@group
---------- Buffer: foo ----------
@point{}He said "Please!  Find
the ball boy!"
---------- Buffer: foo ----------
@end group

@group
(word-search-forward "Please find the ball, boy.")
     @result{} 35

---------- Buffer: foo ----------
He said "Please!  Find
the ball boy@point{}!"
---------- Buffer: foo ----------
@end group
@end example

If @var{limit} is non-@code{nil} (it must be a position in the current
buffer), then it is the upper bound to the search.  The match found must
not extend after that position.

If @var{noerror} is @code{nil}, then @code{word-search-forward} signals
an error if the search fails.  If @var{noerror} is @code{t}, then it
returns @code{nil} instead of signaling an error.  If @var{noerror} is
neither @code{nil} nor @code{t}, it moves point to @var{limit} (or the
end of the buffer) and returns @code{nil}.

If @var{repeat} is non-@code{nil}, then the search is repeated that many
times.  Point is positioned at the end of the last match.
@end deffn

@deffn Command word-search-backward string &optional limit noerror repeat
This function searches backward from point for a word match to
@var{string}.  This function is just like @code{word-search-forward}
except that it searches backward and normally leaves point at the
beginning of the match.
@end deffn

@node Regular Expressions
@section Regular Expressions
@cindex regular expression
@cindex regexp

  A @dfn{regular expression} (@dfn{regexp}, for short) is a pattern that
denotes a (possibly infinite) set of strings.  Searching for matches for
a regexp is a very powerful operation.  This section explains how to write
regexps; the following section says how to search for them.

@menu
* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Functions::        Functions for operating on regular expressions.
* Regexp Example::          Illustrates regular expression syntax.
@end menu

@node Syntax of Regexps
@subsection Syntax of Regular Expressions

  Regular expressions have a syntax in which a few characters are
special constructs and the rest are @dfn{ordinary}.  An ordinary
character is a simple regular expression that matches that character and
nothing else.  The special characters are @samp{.}, @samp{*}, @samp{+},
@samp{?}, @samp{[}, @samp{]}, @samp{^}, @samp{$}, and @samp{\}; no new
special characters will be defined in the future.  Any other character
appearing in a regular expression is ordinary, unless a @samp{\}
precedes it.

  For example, @samp{f} is not a special character, so it is ordinary, and
therefore @samp{f} is a regular expression that matches the string
@samp{f} and no other string.  (It does @emph{not} match the string
@samp{fg}, but it does match a @emph{part} of that string.)  Likewise,
@samp{o} is a regular expression that matches only @samp{o}.@refill

  Any two regular expressions @var{a} and @var{b} can be concatenated.  The
result is a regular expression that matches a string if @var{a} matches
some amount of the beginning of that string and @var{b} matches the rest of
the string.@refill

  As a simple example, we can concatenate the regular expressions @samp{f}
and @samp{o} to get the regular expression @samp{fo}, which matches only
the string @samp{fo}.  Still trivial.  To do something more powerful, you
need to use one of the special regular expression constructs.

@menu
* Regexp Special::      Special characters in regular expressions.
* Char Classes::        Character classes used in regular expressions.
* Regexp Backslash::    Backslash-sequences in regular expressions.
@end menu

@node Regexp Special
@subsubsection Special Characters in Regular Expressions

  Here is a list of the characters that are special in a regular
expression.

@need 800
@table @asis
@item @samp{.}@: @r{(Period)}
@cindex @samp{.} in regexp
is a special character that matches any single character except a newline.
Using concatenation, we can make regular expressions like @samp{a.b}, which
matches any three-character string that begins with @samp{a} and ends with
@samp{b}.@refill

@item @samp{*}
@cindex @samp{*} in regexp
is not a construct by itself; it is a postfix operator that means to
match the preceding regular expression repetitively as many times as
possible.  Thus, @samp{o*} matches any number of @samp{o}s (including no
@samp{o}s).

@samp{*} always applies to the @emph{smallest} possible preceding
expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating
@samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on.

The matcher processes a @samp{*} construct by matching, immediately, as
many repetitions as can be found.  Then it continues with the rest of
the pattern.  If that fails, backtracking occurs, discarding some of the
matches of the @samp{*}-modified construct in the hope that that will
make it possible to match the rest of the pattern.  For example, in
matching @samp{ca*ar} against the string @samp{caaar}, the @samp{a*}
first tries to match all three @samp{a}s; but the rest of the pattern is
@samp{ar} and there is only @samp{r} left to match, so this try fails.
The next alternative is for @samp{a*} to match only two @samp{a}s.  With
this choice, the rest of the regexp matches successfully.@refill

Nested repetition operators can be extremely slow if they specify
backtracking loops.  For example, it could take hours for the regular
expression @samp{\(x+y*\)*a} to try to match the sequence
@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz}, before it ultimately fails.
The slowness is because Emacs must try each imaginable way of grouping
the 35 @samp{x}s before concluding that none of them can work.  To make
sure your regular expressions run fast, check nested repetitions
carefully.

@item @samp{+}
@cindex @samp{+} in regexp
is a postfix operator, similar to @samp{*} except that it must match
the preceding expression at least once.  So, for example, @samp{ca+r}
matches the strings @samp{car} and @samp{caaaar} but not the string
@samp{cr}, whereas @samp{ca*r} matches all three strings.

@item @samp{?}
@cindex @samp{?} in regexp
is a postfix operator, similar to @samp{*} except that it must match the
preceding expression either once or not at all.  For example,
@samp{ca?r} matches @samp{car} or @samp{cr}; nothing else.

@item @samp{*?}, @samp{+?}, @samp{??}
These are ``non-greedy'' variants of the operators @samp{*}, @samp{+}
and @samp{?}.  Where those operators match the largest possible
substring (consistent with matching the entire containing expression),
the non-greedy variants match the smallest possible substring
(consistent with matching the entire containing expression).

For example, the regular expression @samp{c[ad]*a} when applied to the
string @samp{cdaaada} matches the whole string; but the regular
expression @samp{c[ad]*?a}, applied to that same string, matches just
@samp{cda}.  (The smallest possible match here for @samp{[ad]*?} that
permits the whole expression to match is @samp{d}.)

@item @samp{[ @dots{} ]}
@cindex character alternative (in regexp)
@cindex @samp{[} in regexp
@cindex @samp{]} in regexp
is a @dfn{character alternative}, which begins with @samp{[} and is
terminated by @samp{]}.  In the simplest case, the characters between
the two brackets are what this character alternative can match.

Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and
@samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s
(including the empty string), from which it follows that @samp{c[ad]*r}
matches @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc.

You can also include character ranges in a character alternative, by
writing the starting and ending characters with a @samp{-} between them.
Thus, @samp{[a-z]} matches any lower-case @sc{ascii} letter.  Ranges may be
intermixed freely with individual characters, as in @samp{[a-z$%.]},
which matches any lower case @sc{ascii} letter or @samp{$}, @samp{%} or
period.

Note that the usual regexp special characters are not special inside a
character alternative.  A completely different set of characters is
special inside character alternatives: @samp{]}, @samp{-} and @samp{^}.

To include a @samp{]} in a character alternative, you must make it the
first character.  For example, @samp{[]a]} matches @samp{]} or @samp{a}.
To include a @samp{-}, write @samp{-} as the first or last character of
the character alternative, or put it after a range.  Thus, @samp{[]-]}
matches both @samp{]} and @samp{-}.

To include @samp{^} in a character alternative, put it anywhere but at
the beginning.

The beginning and end of a range of multibyte characters must be in
the same character set (@pxref{Character Sets}).  Thus,
@code{"[\x8e0-\x97c]"} is invalid because character 0x8e0 (@samp{a}
with grave accent) is in the Emacs character set for Latin-1 but the
character 0x97c (@samp{u} with diaeresis) is in the Emacs character
set for Latin-2.  (We use Lisp string syntax to write that example,
and a few others in the next few paragraphs, in order to include hex
escape sequences in them.)

If a range starts with a unibyte character @var{c} and ends with a
multibyte character @var{c2}, the range is divided into two parts: one
is @samp{@var{c}..?\377}, the other is @samp{@var{c1}..@var{c2}}, where
@var{c1} is the first character of the charset to which @var{c2}
belongs.
 
You cannot always match all non-@sc{ascii} characters with the regular
expression @code{"[\200-\377]"}.  This works when searching a unibyte
buffer or string (@pxref{Text Representations}), but not in a multibyte
buffer or string, because many non-@sc{ascii} characters have codes
above octal 0377.  However, the regular expression @code{"[^\000-\177]"}
does match all non-@sc{ascii} characters (see below regarding @samp{^}),
in both multibyte and unibyte representations, because only the
@sc{ascii} characters are excluded.

Starting in Emacs 21, a character alternative can also specify named
character classes (@pxref{Char Classes}).  This is a POSIX feature whose
syntax is @samp{[:@var{class}:]}.  Using a character class is equivalent
to mentioning each of the characters in that class; but the latter is
not feasible in practice, since some classes include thousands of
different characters.

@item @samp{[^ @dots{} ]}
@cindex @samp{^} in regexp
@samp{[^} begins a @dfn{complemented character alternative}, which matches any
character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches
all characters @emph{except} letters and digits.

@samp{^} is not special in a character alternative unless it is the first
character.  The character following the @samp{^} is treated as if it
were first (in other words, @samp{-} and @samp{]} are not special there).

A complemented character alternative can match a newline, unless newline is
mentioned as one of the characters not to match.  This is in contrast to
the handling of regexps in programs such as @code{grep}.

@item @samp{^}
@cindex beginning of line in regexp
is a special character that matches the empty string, but only at the
beginning of a line in the text being matched.  Otherwise it fails to
match anything.  Thus, @samp{^foo} matches a @samp{foo} that occurs at
the beginning of a line.

When matching a string instead of a buffer, @samp{^} matches at the
beginning of the string or after a newline character.

For historical compatibility reasons, @samp{^} can be used only at the
beginning of the regular expression, or after @samp{\(} or @samp{\|}.

@item @samp{$}
@cindex @samp{$} in regexp
@cindex end of line in regexp
is similar to @samp{^} but matches only at the end of a line.  Thus,
@samp{x+$} matches a string of one @samp{x} or more at the end of a line.

When matching a string instead of a buffer, @samp{$} matches at the end
of the string or before a newline character.

For historical compatibility reasons, @samp{$} can be used only at the
end of the regular expression, or before @samp{\)} or @samp{\|}.

@item @samp{\}
@cindex @samp{\} in regexp
has two functions: it quotes the special characters (including
@samp{\}), and it introduces additional special constructs.

Because @samp{\} quotes special characters, @samp{\$} is a regular
expression that matches only @samp{$}, and @samp{\[} is a regular
expression that matches only @samp{[}, and so on.

Note that @samp{\} also has special meaning in the read syntax of Lisp
strings (@pxref{String Type}), and must be quoted with @samp{\}.  For
example, the regular expression that matches the @samp{\} character is
@samp{\\}.  To write a Lisp string that contains the characters
@samp{\\}, Lisp syntax requires you to quote each @samp{\} with another
@samp{\}.  Therefore, the read syntax for a regular expression matching
@samp{\} is @code{"\\\\"}.@refill
@end table

@strong{Please note:} For historical compatibility, special characters
are treated as ordinary ones if they are in contexts where their special
meanings make no sense.  For example, @samp{*foo} treats @samp{*} as
ordinary since there is no preceding expression on which the @samp{*}
can act.  It is poor practice to depend on this behavior; quote the
special character anyway, regardless of where it appears.@refill

@node Char Classes
@subsubsection Character Classes
@cindex character classes in regexp

  Here is a table of the classes you can use in a character alternative,
in Emacs 21, and what they mean:

@table @samp
@item [:ascii:]
This matches any @sc{ascii} (unibyte) character.
@item [:alnum:]
This matches any letter or digit.  (At present, for multibyte
characters, it matches anything that has word syntax.)
@item [:alpha:]
This matches any letter.  (At present, for multibyte characters, it
matches anything that has word syntax.)
@item [:blank:]
This matches space and tab only.
@item [:cntrl:]
This matches any @sc{ascii} control character.
@item [:digit:]
This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]}
matches any digit, as well as @samp{+} and @samp{-}.
@item [:graph:]
This matches graphic characters---everything except @sc{ascii} control
characters, space, and the delete character.
@item [:lower:]
This matches any lower-case letter, as determined by
the current case table (@pxref{Case Tables}).
@item [:nonascii:]
This matches any non-@sc{ascii} (multibyte) character.
@item [:print:]
This matches printing characters---everything except @sc{ascii} control
characters and the delete character.
@item [:punct:]
This matches any punctuation character.  (At present, for multibyte
characters, it matches anything that has non-word syntax.)
@item [:space:]
This matches any character that has whitespace syntax
(@pxref{Syntax Class Table}).
@item [:upper:]
This matches any upper-case letter, as determined by
the current case table (@pxref{Case Tables}).
@item [:word:]
This matches any character that has word syntax (@pxref{Syntax Class
Table}).
@item [:xdigit:]
This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a}
through @samp{f} and @samp{A} through @samp{F}.
@end table

@node Regexp Backslash
@subsubsection Backslash Constructs in Regular Expressions

  For the most part, @samp{\} followed by any character matches only
that character.  However, there are several exceptions: certain
two-character sequences starting with @samp{\} that have special
meanings.  (The character after the @samp{\} in such a sequence is
always ordinary when used on its own.)  Here is a table of the special
@samp{\} constructs.

@table @samp
@item \|
@cindex @samp{|} in regexp
@cindex regexp alternative
specifies an alternative.
Two regular expressions @var{a} and @var{b} with @samp{\|} in
between form an expression that matches anything that either @var{a} or
@var{b} matches.@refill

Thus, @samp{foo\|bar} matches either @samp{foo} or @samp{bar}
but no other string.@refill

@samp{\|} applies to the largest possible surrounding expressions.  Only a
surrounding @samp{\( @dots{} \)} grouping can limit the grouping power of
@samp{\|}.@refill

Full backtracking capability exists to handle multiple uses of
@samp{\|}, if you use the POSIX regular expression functions
(@pxref{POSIX Regexps}).

@item \@{@var{m}\@}
is a postfix operator that repeats the previous pattern exactly @var{m}
times.  Thus, @samp{x\@{5\@}} matches the string @samp{xxxxx}
and nothing else.  @samp{c[ad]\@{3\@}r} matches string such as
@samp{caaar}, @samp{cdddr}, @samp{cadar}, and so on.

@item \@{@var{m},@var{n}\@}
is more general postfix operator that specifies repetition with a
minimum of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m}
is omitted, the minimum is 0; if @var{n} is omitted, there is no
maximum.

For example, @samp{c[ad]\@{1,2\@}r} matches the strings @samp{car},
@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and
nothing else.@*
@samp{\@{0,1\@}} or @samp{\@{,1\@}} is equivalent to @samp{?}.	@*
@samp{\@{0,\@}} or @samp{\@{,\@}} is equivalent to @samp{*}.	@*
@samp{\@{1,\@}} is equivalent to @samp{+}.

@item \( @dots{} \)
@cindex @samp{(} in regexp
@cindex @samp{)} in regexp
@cindex regexp grouping
is a grouping construct that serves three purposes:

@enumerate
@item
To enclose a set of @samp{\|} alternatives for other operations.  Thus,
the regular expression @samp{\(foo\|bar\)x} matches either @samp{foox}
or @samp{barx}.

@item
To enclose a complicated expression for the postfix operators @samp{*},
@samp{+} and @samp{?} to operate on.  Thus, @samp{ba\(na\)*} matches
@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any
number (zero or more) of @samp{na} strings.

@item
To record a matched substring for future reference with
@samp{\@var{digit}} (see below).
@end enumerate

This last application is not a consequence of the idea of a
parenthetical grouping; it is a separate feature that was assigned as a
second meaning to the same @samp{\( @dots{} \)} construct because, in
pratice, there was usually no conflict between the two meanings.  But
occasionally there is a conflict, and that led to the introduction of
shy groups.

@item \(?: @dots{} \)
is the @dfn{shy group} construct.  A shy group serves the first two
purposes of an ordinary group (controlling the nesting of other
operators), but it does not get a number, so you cannot refer back to
its value with @samp{\@var{digit}}.

Shy groups are particulary useful for mechanically-constructed regular
expressions because they can be added automatically without altering the
numbering of any ordinary, non-shy groups.

@item \@var{digit}
matches the same text that matched the @var{digit}th occurrence of a
grouping (@samp{\( @dots{} \)}) construct.

In other words, after the end of a group, the matcher remembers the
beginning and end of the text matched by that group.  Later on in the
regular expression you can use @samp{\} followed by @var{digit} to
match that same text, whatever it may have been.

The strings matching the first nine grouping constructs appearing in
the entire regular expression passed to a search or matching function
are assigned numbers 1 through 9 in the order that the open
parentheses appear in the regular expression.  So you can use
@samp{\1} through @samp{\9} to refer to the text matched by the
corresponding grouping constructs.

For example, @samp{\(.*\)\1} matches any newline-free string that is
composed of two identical halves.  The @samp{\(.*\)} matches the first
half, which may be anything, but the @samp{\1} that follows must match
the same exact text.

If a particular grouping construct in the regular expression was never
matched---for instance, if it appears inside of an alternative that
wasn't used, or inside of a repetition that repeated zero times---then
the corresponding @samp{\@var{digit}} construct never matches
anything.  To use an artificial example,, @samp{\(foo\(b*\)\|lose\)\2}
cannot match @samp{lose}: the second alternative inside the larger
group matches it, but then @samp{\2} is undefined and can't match
anything.  But it can match @samp{foobb}, because the first
alternative matches @samp{foob} and @samp{\2} matches @samp{b}.

@item \w
@cindex @samp{\w} in regexp
matches any word-constituent character.  The editor syntax table
determines which characters these are.  @xref{Syntax Tables}.

@item \W
@cindex @samp{\W} in regexp
matches any character that is not a word constituent.

@item \s@var{code}
@cindex @samp{\s} in regexp
matches any character whose syntax is @var{code}.  Here @var{code} is a
character that represents a syntax code: thus, @samp{w} for word
constituent, @samp{-} for whitespace, @samp{(} for open parenthesis,
etc.  To represent whitespace syntax, use either @samp{-} or a space
character.  @xref{Syntax Class Table}, for a list of syntax codes and
the characters that stand for them.

@item \S@var{code}
@cindex @samp{\S} in regexp
matches any character whose syntax is not @var{code}.

@item \c@var{c}
matches any character whose category is @var{c}.  Here @var{c} is a
character that represents a category: thus, @samp{c} for Chinese
characters or @samp{g} for Greek characters in the standard category
table.

@item \C@var{c}
matches any character whose category is not @var{c}.
@end table

  The following regular expression constructs match the empty string---that is,
they don't use up any characters---but whether they match depends on the
context.

@table @samp
@item \`
@cindex @samp{\`} in regexp
matches the empty string, but only at the beginning
of the buffer or string being matched against.

@item \'
@cindex @samp{\'} in regexp
matches the empty string, but only at the end of
the buffer or string being matched against.

@item \=
@cindex @samp{\=} in regexp
matches the empty string, but only at point.
(This construct is not defined when matching against a string.)

@item \b
@cindex @samp{\b} in regexp
matches the empty string, but only at the beginning or
end of a word.  Thus, @samp{\bfoo\b} matches any occurrence of
@samp{foo} as a separate word.  @samp{\bballs?\b} matches
@samp{ball} or @samp{balls} as a separate word.@refill

@samp{\b} matches at the beginning or end of the buffer
regardless of what text appears next to it.

@item \B
@cindex @samp{\B} in regexp
matches the empty string, but @emph{not} at the beginning or
end of a word.

@item \<
@cindex @samp{\<} in regexp
matches the empty string, but only at the beginning of a word.
@samp{\<} matches at the beginning of the buffer only if a
word-constituent character follows.

@item \>
@cindex @samp{\>} in regexp
matches the empty string, but only at the end of a word.  @samp{\>}
matches at the end of the buffer only if the contents end with a
word-constituent character.
@end table

@kindex invalid-regexp
  Not every string is a valid regular expression.  For example, a string
with unbalanced square brackets is invalid (with a few exceptions, such
as @samp{[]]}), and so is a string that ends with a single @samp{\}.  If
an invalid regular expression is passed to any of the search functions,
an @code{invalid-regexp} error is signaled.

@node Regexp Example
@comment  node-name,  next,  previous,  up
@subsection Complex Regexp Example

  Here is a complicated regexp, used by Emacs to recognize the end of a
sentence together with any whitespace that follows.  It is the value of
the variable @code{sentence-end}.  

  First, we show the regexp as a string in Lisp syntax to distinguish
spaces from tab characters.  The string constant begins and ends with a
double-quote.  @samp{\"} stands for a double-quote as part of the
string, @samp{\\} for a backslash as part of the string, @samp{\t} for a
tab and @samp{\n} for a newline.

@example
"[.?!][]\"')@}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
@end example

@noindent
In contrast, if you evaluate the variable @code{sentence-end}, you
will see the following:

@example
@group
sentence-end
     @result{} "[.?!][]\"')@}]*\\($\\| $\\|  \\|  \\)[       
]*"
@end group
@end example

@noindent
In this output, tab and newline appear as themselves.

  This regular expression contains four parts in succession and can be
deciphered as follows:

@table @code
@item [.?!]
The first part of the pattern is a character alternative that matches
any one of three characters: period, question mark, and exclamation
mark.  The match must begin with one of these three characters.

@item []\"')@}]*
The second part of the pattern matches any closing braces and quotation
marks, zero or more of them, that may follow the period, question mark
or exclamation mark.  The @code{\"} is Lisp syntax for a double-quote in
a string.  The @samp{*} at the end indicates that the immediately
preceding regular expression (a character alternative, in this case) may be
repeated zero or more times.

@item \\($\\|@ $\\|\t\\|@ @ \\)
The third part of the pattern matches the whitespace that follows the
end of a sentence: the end of a line (optionally with a space), or a
tab, or two spaces.  The double backslashes mark the parentheses and
vertical bars as regular expression syntax; the parentheses delimit a
group and the vertical bars separate alternatives.  The dollar sign is
used to match the end of a line.

@item [ \t\n]*
Finally, the last part of the pattern matches any additional whitespace
beyond the minimum needed to end a sentence.
@end table

@node Regexp Functions
@subsection Regular Expression Functions

  These functions operate on regular expressions.

@defun regexp-quote string
This function returns a regular expression whose only exact match is
@var{string}.  Using this regular expression in @code{looking-at} will
succeed only if the next characters in the buffer are @var{string};
using it in a search function will succeed if the text being searched
contains @var{string}.

This allows you to request an exact string match or search when calling
a function that wants a regular expression.

@example
@group
(regexp-quote "^The cat$")
     @result{} "\\^The cat\\$"
@end group
@end example

One use of @code{regexp-quote} is to combine an exact string match with
context described as a regular expression.  For example, this searches
for the string that is the value of @var{string}, surrounded by
whitespace:

@example
@group
(re-search-forward
 (concat "\\s-" (regexp-quote string) "\\s-"))
@end group
@end example
@end defun

@defun regexp-opt strings &optional paren
This function returns an efficient regular expression that will match
any of the strings @var{strings}.  This is useful when you need to make
matching or searching as fast as possible---for example, for Font Lock
mode.

If the optional argument @var{paren} is non-@code{nil}, then the
returned regular expression is always enclosed by at least one
parentheses-grouping construct.

This simplified definition of @code{regexp-opt} produces a
regular expression which is equivalent to the actual value
(but not as efficient):

@example
(defun regexp-opt (strings paren)
  (let ((open-paren (if paren "\\(" ""))
        (close-paren (if paren "\\)" "")))
    (concat open-paren
            (mapconcat 'regexp-quote strings "\\|")
            close-paren)))
@end example
@end defun

@defun regexp-opt-depth regexp
This function returns the total number of grouping constructs
(parenthesized expressions) in @var{regexp}.
@end defun

@node Regexp Search
@section Regular Expression Searching
@cindex regular expression searching
@cindex regexp searching
@cindex searching for regexp

  In GNU Emacs, you can search for the next match for a regular
expression either incrementally or not.  For incremental search
commands, see @ref{Regexp Search, , Regular Expression Search, emacs,
The GNU Emacs Manual}.  Here we describe only the search functions
useful in programs.  The principal one is @code{re-search-forward}.

  These search functions convert the regular expression to multibyte if
the buffer is multibyte; they convert the regular expression to unibyte
if the buffer is unibyte.  @xref{Text Representations}.

@deffn Command re-search-forward regexp &optional limit noerror repeat
This function searches forward in the current buffer for a string of
text that is matched by the regular expression @var{regexp}.  The
function skips over any amount of text that is not matched by
@var{regexp}, and leaves point at the end of the first match found.
It returns the new value of point.

If @var{limit} is non-@code{nil} (it must be a position in the current
buffer), then it is the upper bound to the search.  No match extending
after that position is accepted.

If @var{repeat} is supplied (it must be a positive number), then the
search is repeated that many times (each time starting at the end of the
previous time's match).  If all these successive searches succeed, the
function succeeds, moving point and returning its new value.  Otherwise
the function fails.

What happens when the function fails depends on the value of
@var{noerror}.  If @var{noerror} is @code{nil}, a @code{search-failed}
error is signaled.  If @var{noerror} is @code{t},
@code{re-search-forward} does nothing and returns @code{nil}.  If
@var{noerror} is neither @code{nil} nor @code{t}, then
@code{re-search-forward} moves point to @var{limit} (or the end of the
buffer) and returns @code{nil}.

In the following example, point is initially before the @samp{T}.
Evaluating the search call moves point to the end of that line (between
the @samp{t} of @samp{hat} and the newline).

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------
@end group

@group
(re-search-forward "[a-z]+" nil t 5)
     @result{} 27

---------- Buffer: foo ----------
I read "The cat in the hat@point{}
comes back" twice.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command re-search-backward regexp &optional limit noerror repeat
This function searches backward in the current buffer for a string of
text that is matched by the regular expression @var{regexp}, leaving
point at the beginning of the first text found.

This function is analogous to @code{re-search-forward}, but they are not
simple mirror images.  @code{re-search-forward} finds the match whose
beginning is as close as possible to the starting point.  If
@code{re-search-backward} were a perfect mirror image, it would find the
match whose end is as close as possible.  However, in fact it finds the
match whose beginning is as close as possible.  The reason for this is that
matching a regular expression at a given spot always works from
beginning to end, and starts at a specified beginning position.

A true mirror-image of @code{re-search-forward} would require a special
feature for matching regular expressions from end to beginning.  It's
not worth the trouble of implementing that.
@end deffn

@defun string-match regexp string &optional start
This function returns the index of the start of the first match for
the regular expression @var{regexp} in @var{string}, or @code{nil} if
there is no match.  If @var{start} is non-@code{nil}, the search starts
at that index in @var{string}.

For example,

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly.")
     @result{} 4
@end group
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group
@end example

@noindent
The index of the first character of the
string is 0, the index of the second character is 1, and so on.

After this function returns, the index of the first character beyond
the match is available as @code{(match-end 0)}.  @xref{Match Data}.

@example
@group
(string-match
 "quick" "The quick brown fox jumped quickly." 8)
     @result{} 27
@end group

@group
(match-end 0)
     @result{} 32
@end group
@end example
@end defun

@defun looking-at regexp
This function determines whether the text in the current buffer directly
following point matches the regular expression @var{regexp}.  ``Directly
following'' means precisely that: the search is ``anchored'' and it can
succeed only starting with the first character following point.  The
result is @code{t} if so, @code{nil} otherwise.

This function does not move point, but it updates the match data, which
you can access using @code{match-beginning} and @code{match-end}.
@xref{Match Data}.

In this example, point is located directly before the @samp{T}.  If it
were anywhere else, the result would be @code{nil}.

@example
@group
---------- Buffer: foo ----------
I read "@point{}The cat in the hat
comes back" twice.
---------- Buffer: foo ----------

(looking-at "The cat in the hat$")
     @result{} t
@end group
@end example
@end defun

@node POSIX Regexps
@section POSIX Regular Expression Searching

  The usual regular expression functions do backtracking when necessary
to handle the @samp{\|} and repetition constructs, but they continue
this only until they find @emph{some} match.  Then they succeed and
report the first match found.

  This section describes alternative search functions which perform the
full backtracking specified by the POSIX standard for regular expression
matching.  They continue backtracking until they have tried all
possibilities and found all matches, so they can report the longest
match, as required by POSIX.  This is much slower, so use these
functions only when you really need the longest match.

@defun posix-search-forward regexp &optional limit noerror repeat
This is like @code{re-search-forward} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@defun posix-search-backward regexp &optional limit noerror repeat
This is like @code{re-search-backward} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@defun posix-looking-at regexp
This is like @code{looking-at} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@defun posix-string-match regexp string &optional start
This is like @code{string-match} except that it performs the full
backtracking specified by the POSIX standard for regular expression
matching.
@end defun

@ignore
@deffn Command delete-matching-lines regexp
This function is identical to @code{delete-non-matching-lines}, save
that it deletes what @code{delete-non-matching-lines} keeps.

In the example below, point is located on the first line of text.

@example
@group
---------- Buffer: foo ----------
We hold these truths
to be self-evident,
that all men are created
equal, and that they are
---------- Buffer: foo ----------
@end group

@group
(delete-matching-lines "the")
     @result{} nil

---------- Buffer: foo ----------
to be self-evident,
that all men are created
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command flush-lines regexp
This function is the same as @code{delete-matching-lines}.
@end deffn

@defun delete-non-matching-lines regexp
This function deletes all lines following point which don't
contain a match for the regular expression @var{regexp}.
@end defun

@deffn Command keep-lines regexp
This function is the same as @code{delete-non-matching-lines}.
@end deffn

@deffn Command how-many regexp
This function counts the number of matches for @var{regexp} there are in
the current buffer following point.  It prints this number in
the echo area, returning the string printed.
@end deffn

@deffn Command count-matches regexp
This function is a synonym of @code{how-many}.
@end deffn

@deffn Command list-matching-lines regexp &optional nlines
This function is a synonym of @code{occur}.
Show all lines following point containing a match for @var{regexp}.
Display each line with @var{nlines} lines before and after,
or @code{-}@var{nlines} before if @var{nlines} is negative.
@var{nlines} defaults to @code{list-matching-lines-default-context-lines}.
Interactively it is the prefix arg.

The lines are shown in a buffer named @samp{*Occur*}.
It serves as a menu to find any of the occurrences in this buffer.
@kbd{C-h m} (@code{describe-mode}) in that buffer gives help.
@end deffn

@defopt list-matching-lines-default-context-lines
Default value is 0.
Default number of context lines to include around a @code{list-matching-lines}
match.  A negative number means to include that many lines before the match.
A positive number means to include that many lines both before and after.
@end defopt
@end ignore

@node Search and Replace
@section Search and Replace
@cindex replacement

@defun perform-replace from-string replacements start end query-flag regexp-flag delimited-flag &optional repeat-count map
This function is the guts of @code{query-replace} and related
commands.  It searches for occurrences of @var{from-string} in the
text between positions @var{start} and @var{end} and replaces some or
all of them.  If @var{start} is @code{nil}, point is used instead, and
the buffer's end is used for @var{end}.

If @var{query-flag} is @code{nil}, it replaces all
occurrences; otherwise, it asks the user what to do about each one.

If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is
considered a regular expression; otherwise, it must match literally.  If
@var{delimited-flag} is non-@code{nil}, then only replacements
surrounded by word boundaries are considered.

The argument @var{replacements} specifies what to replace occurrences
with.  If it is a string, that string is used.  It can also be a list of
strings, to be used in cyclic order.

If @var{replacements} is a cons cell, @code{(@var{function}
. @var{data})}, this means to call @var{function} after each match to
get the replacement text.  This function is called with two arguments:
@var{data}, and the number of replacements already made.

If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then
it specifies how many times to use each of the strings in the
@var{replacements} list before advancing cyclicly to the next one.

If @var{from-string} contains upper-case letters, then
@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and
it uses the @code{replacements} without altering the case of them.

Normally, the keymap @code{query-replace-map} defines the possible user
responses for queries.  The argument @var{map}, if non-@code{nil}, is a
keymap to use instead of @code{query-replace-map}.
@end defun

@defvar query-replace-map
This variable holds a special keymap that defines the valid user
responses for @code{query-replace} and related functions, as well as
@code{y-or-n-p} and @code{map-y-or-n-p}.  It is unusual in two ways:

@itemize @bullet
@item
The ``key bindings'' are not commands, just symbols that are meaningful
to the functions that use this map.

@item
Prefix keys are not supported; each key binding must be for a
single-event key sequence.  This is because the functions don't use
@code{read-key-sequence} to get the input; instead, they read a single
event and look it up ``by hand.''
@end itemize
@end defvar

Here are the meaningful ``bindings'' for @code{query-replace-map}.
Several of them are meaningful only for @code{query-replace} and
friends.

@table @code
@item act
Do take the action being considered---in other words, ``yes.''

@item skip
Do not take action for this question---in other words, ``no.''

@item exit
Answer this question ``no,'' and give up on the entire series of
questions, assuming that the answers will be ``no.''

@item act-and-exit
Answer this question ``yes,'' and give up on the entire series of
questions, assuming that subsequent answers will be ``no.''

@item act-and-show
Answer this question ``yes,'' but show the results---don't advance yet
to the next question.

@item automatic
Answer this question and all subsequent questions in the series with
``yes,'' without further user interaction.

@item backup
Move back to the previous place that a question was asked about.

@item edit
Enter a recursive edit to deal with this question---instead of any
other action that would normally be taken.

@item delete-and-edit
Delete the text being considered, then enter a recursive edit to replace
it.

@item recenter
Redisplay and center the window, then ask the same question again.

@item quit
Perform a quit right away.  Only @code{y-or-n-p} and related functions
use this answer.

@item help
Display some help, then ask again.
@end table

@node Match Data
@section The Match Data
@cindex match data

  Emacs keeps track of the start and end positions of the segments of
text found during a regular expression search.  This means, for example,
that you can search for a complex pattern, such as a date in an Rmail
message, and then extract parts of the match under control of the
pattern.

  Because the match data normally describe the most recent search only,
you must be careful not to do another search inadvertently between the
search you wish to refer back to and the use of the match data.  If you
can't avoid another intervening search, you must save and restore the
match data around it, to prevent it from being overwritten.

@menu
* Replacing Match::	  Replacing a substring that was matched.
* Simple Match Data::     Accessing single items of match data,
			    such as where a particular subexpression started.
* Entire Match Data::     Accessing the entire match data at once, as a list.
* Saving Match Data::     Saving and restoring the match data.
@end menu

@node Replacing Match
@subsection Replacing the Text that Matched

  This function replaces the text matched by the last search with
@var{replacement}.

@cindex case in replacements
@defun replace-match replacement &optional fixedcase literal string subexp
This function replaces the text in the buffer (or in @var{string}) that
was matched by the last search.  It replaces that text with
@var{replacement}.

If you did the last search in a buffer, you should specify @code{nil}
for @var{string}.  Then @code{replace-match} does the replacement by
editing the buffer; it leaves point at the end of the replacement text,
and returns @code{t}.

If you did the search in a string, pass the same string as @var{string}.
Then @code{replace-match} does the replacement by constructing and
returning a new string.

If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses
the replacement text without case conversion; otherwise, it converts
the replacement text depending upon the capitalization of the text to
be replaced.  If the original text is all upper case, this converts
the replacement text to upper case.  If all words of the original text
are capitalized, this capitalizes all the words of the replacement
text.  If all the words are one-letter and they are all upper case,
they are treated as capitalized words rather than all-upper-case
words.

If @var{literal} is non-@code{nil}, then @var{replacement} is inserted
exactly as it is, the only alterations being case changes as needed.
If it is @code{nil} (the default), then the character @samp{\} is treated
specially.  If a @samp{\} appears in @var{replacement}, then it must be
part of one of the following sequences:

@table @asis
@item @samp{\&}
@cindex @samp{&} in replacement
@samp{\&} stands for the entire text being replaced.

@item @samp{\@var{n}}
@cindex @samp{\@var{n}} in replacement
@samp{\@var{n}}, where @var{n} is a digit, stands for the text that
matched the @var{n}th subexpression in the original regexp.
Subexpressions are those expressions grouped inside @samp{\(@dots{}\)}.

@item @samp{\\}
@cindex @samp{\} in replacement
@samp{\\} stands for a single @samp{\} in the replacement text.
@end table

These substitutions occur after case conversion, if any,
so the strings they substitute are never case-converted.

If @var{subexp} is non-@code{nil}, that says to replace just
subexpression number @var{subexp} of the regexp that was matched, not
the entire match.  For example, after matching @samp{foo \(ba*r\)},
calling @code{replace-match} with 1 as @var{subexp} means to replace
just the text that matched @samp{\(ba*r\)}.
@end defun

@node Simple Match Data
@subsection Simple Match Data Access

  This section explains how to use the match data to find out what was
matched by the last search or match operation.

  You can ask about the entire matching text, or about a particular
parenthetical subexpression of a regular expression.  The @var{count}
argument in the functions below specifies which.  If @var{count} is
zero, you are asking about the entire match.  If @var{count} is
positive, it specifies which subexpression you want.

  Recall that the subexpressions of a regular expression are those
expressions grouped with escaped parentheses, @samp{\(@dots{}\)}.  The
@var{count}th subexpression is found by counting occurrences of
@samp{\(} from the beginning of the whole regular expression.  The first
subexpression is numbered 1, the second 2, and so on.  Only regular
expressions can have subexpressions---after a simple string search, the
only information available is about the entire match.

  A search which fails may or may not alter the match data.  In the
past, a failing search did not do this, but we may change it in the
future.

@defun match-string count &optional in-string
This function returns, as a string, the text matched in the last search
or match operation.  It returns the entire text if @var{count} is zero,
or just the portion corresponding to the @var{count}th parenthetical
subexpression, if @var{count} is positive.

If the last such operation was done against a string with
@code{string-match}, then you should pass the same string as the
argument @var{in-string}.  After a buffer search or match,
you should omit @var{in-string} or pass @code{nil} for it; but you
should make sure that the current buffer when you call
@code{match-string} is the one in which you did the searching or
matching.

The value is @code{nil} if @var{count} is out of range, or for a
subexpression inside a @samp{\|} alternative that wasn't used or a
repetition that repeated zero times.
@end defun

@defun match-string-no-properties count &optional in-string
This function is like @code{match-string} except that the result
has no text properties.
@end defun

@defun match-beginning count
This function returns the position of the start of text matched by the
last regular expression searched for, or a subexpression of it.

If @var{count} is zero, then the value is the position of the start of
the entire match.  Otherwise, @var{count} specifies a subexpression in
the regular expression, and the value of the function is the starting
position of the match for that subexpression.

The value is @code{nil} for a subexpression inside a @samp{\|}
alternative that wasn't used or a repetition that repeated zero times.
@end defun

@defun match-end count
This function is like @code{match-beginning} except that it returns the
position of the end of the match, rather than the position of the
beginning.
@end defun

  Here is an example of using the match data, with a comment showing the
positions within the text:

@example
@group
(string-match "\\(qu\\)\\(ick\\)"
              "The quick fox jumped quickly.")
              ;0123456789      
     @result{} 4
@end group

@group
(match-string 0 "The quick fox jumped quickly.")
     @result{} "quick"
(match-string 1 "The quick fox jumped quickly.")
     @result{} "qu"
(match-string 2 "The quick fox jumped quickly.")
     @result{} "ick"
@end group

@group
(match-beginning 1)       ; @r{The beginning of the match}
     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}
@end group

@group
(match-beginning 2)       ; @r{The beginning of the match}
     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}
@end group

@group
(match-end 1)             ; @r{The end of the match}
     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}

(match-end 2)             ; @r{The end of the match}
     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}
@end group
@end example

  Here is another example.  Point is initially located at the beginning
of the line.  Searching moves point to between the space and the word
@samp{in}.  The beginning of the entire match is at the 9th character of
the buffer (@samp{T}), and the beginning of the match for the first
subexpression is at the 13th character (@samp{c}).

@example
@group
(list
  (re-search-forward "The \\(cat \\)")
  (match-beginning 0)
  (match-beginning 1))
    @result{} (9 9 13)
@end group

@group
---------- Buffer: foo ----------
I read "The cat @point{}in the hat comes back" twice.
        ^   ^
        9  13
---------- Buffer: foo ----------
@end group
@end example

@noindent
(In this case, the index returned is a buffer position; the first
character of the buffer counts as 1.)

@node Entire Match Data
@subsection Accessing the Entire Match Data

  The functions @code{match-data} and @code{set-match-data} read or
write the entire match data, all at once.

@defun match-data
This function returns a newly constructed list containing all the
information on what text the last search matched.  Element zero is the
position of the beginning of the match for the whole expression; element
one is the position of the end of the match for the expression.  The
next two elements are the positions of the beginning and end of the
match for the first subexpression, and so on.  In general, element
@ifnottex
number 2@var{n}
@end ifnottex
@tex
number {\mathsurround=0pt $2n$}
@end tex
corresponds to @code{(match-beginning @var{n})}; and
element
@ifnottex
number 2@var{n} + 1
@end ifnottex
@tex
number {\mathsurround=0pt $2n+1$}
@end tex
corresponds to @code{(match-end @var{n})}.

All the elements are markers or @code{nil} if matching was done on a
buffer, and all are integers or @code{nil} if matching was done on a
string with @code{string-match}.

As always, there must be no possibility of intervening searches between
the call to a search function and the call to @code{match-data} that is
intended to access the match data for that search.

@example
@group
(match-data)
     @result{}  (#<marker at 9 in foo>
          #<marker at 17 in foo>
          #<marker at 13 in foo>
          #<marker at 17 in foo>)
@end group
@end example
@end defun

@defun set-match-data match-list
This function sets the match data from the elements of @var{match-list},
which should be a list that was the value of a previous call to
@code{match-data}.  (More precisely, anything that has the same format
will work.)

If @var{match-list} refers to a buffer that doesn't exist, you don't get
an error; that sets the match data in a meaningless but harmless way.

@findex store-match-data
@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}.
@end defun

@node Saving Match Data
@subsection Saving and Restoring the Match Data

  When you call a function that may do a search, you may need to save
and restore the match data around that call, if you want to preserve the
match data from an earlier search for later use.  Here is an example
that shows the problem that arises if you fail to save the match data:

@example
@group
(re-search-forward "The \\(cat \\)")
     @result{} 48
(foo)                   ; @r{Perhaps @code{foo} does}
                        ;   @r{more searching.}
(match-end 0)
     @result{} 61              ; @r{Unexpected result---not 48!}
@end group
@end example

  You can save and restore the match data with @code{save-match-data}:

@defmac save-match-data body@dots{}
This macro executes @var{body}, saving and restoring the match
data around it.
@end defmac

  You could use @code{set-match-data} together with @code{match-data} to
imitate the effect of the special form @code{save-match-data}.  Here is
how:

@example
@group
(let ((data (match-data)))
  (unwind-protect
      @dots{}   ; @r{Ok to change the original match data.}
    (set-match-data data)))
@end group
@end example

  Emacs automatically saves and restores the match data when it runs
process filter functions (@pxref{Filter Functions}) and process
sentinels (@pxref{Sentinels}).

@ignore
  Here is a function which restores the match data provided the buffer
associated with it still exists.

@smallexample
@group
(defun restore-match-data (data)
@c It is incorrect to split the first line of a doc string.
@c If there's a problem here, it should be solved in some other way.
  "Restore the match data DATA unless the buffer is missing."
  (catch 'foo
    (let ((d data))
@end group
      (while d
        (and (car d)
             (null (marker-buffer (car d)))
@group
             ;; @file{match-data} @r{buffer is deleted.}
             (throw 'foo nil))
        (setq d (cdr d)))
      (set-match-data data))))
@end group
@end smallexample
@end ignore

@node Searching and Case
@section Searching and Case
@cindex searching and case

  By default, searches in Emacs ignore the case of the text they are
searching through; if you specify searching for @samp{FOO}, then
@samp{Foo} or @samp{foo} is also considered a match.  This applies to
regular expressions, too; thus, @samp{[aB]} would match @samp{a} or
@samp{A} or @samp{b} or @samp{B}.

  If you do not want this feature, set the variable
@code{case-fold-search} to @code{nil}.  Then all letters must match
exactly, including case.  This is a buffer-local variable; altering the
variable affects only the current buffer.  (@xref{Intro to
Buffer-Local}.)  Alternatively, you may change the value of
@code{default-case-fold-search}, which is the default value of
@code{case-fold-search} for buffers that do not override it.

  Note that the user-level incremental search feature handles case
distinctions differently.  When given a lower case letter, it looks for
a match of either case, but when given an upper case letter, it looks
for an upper case letter only.  But this has nothing to do with the
searching functions used in Lisp code.

@defopt case-replace
This variable determines whether the replacement functions should
preserve case.  If the variable is @code{nil}, that means to use the
replacement text verbatim.  A non-@code{nil} value means to convert the
case of the replacement text according to the text being replaced.

This variable is used by passing it as an argument to the function
@code{replace-match}.  @xref{Replacing Match}.
@end defopt

@defopt case-fold-search
This buffer-local variable determines whether searches should ignore
case.  If the variable is @code{nil} they do not ignore case; otherwise
they do ignore case.
@end defopt

@defvar default-case-fold-search
The value of this variable is the default value for
@code{case-fold-search} in buffers that do not override it.  This is the
same as @code{(default-value 'case-fold-search)}.
@end defvar

@node Standard Regexps
@section Standard Regular Expressions Used in Editing
@cindex regexps used standardly in editing
@cindex standard regexps used in editing

  This section describes some variables that hold regular expressions
used for certain purposes in editing:

@defvar page-delimiter
This is the regular expression describing line-beginnings that separate
pages.  The default value is @code{"^\014"} (i.e., @code{"^^L"} or
@code{"^\C-l"}); this matches a line that starts with a formfeed
character.
@end defvar

  The following two regular expressions should @emph{not} assume the
match always starts at the beginning of a line; they should not use
@samp{^} to anchor the match.  Most often, the paragraph commands do
check for a match only at the beginning of a line, which means that
@samp{^} would be superfluous.  When there is a nonzero left margin,
they accept matches that start after the left margin.  In that case, a
@samp{^} would be incorrect.  However, a @samp{^} is harmless in modes
where a left margin is never used.

@defvar paragraph-separate
This is the regular expression for recognizing the beginning of a line
that separates paragraphs.  (If you change this, you may have to
change @code{paragraph-start} also.)  The default value is
@w{@code{"[@ \t\f]*$"}}, which matches a line that consists entirely of
spaces, tabs, and form feeds (after its left margin).
@end defvar

@defvar paragraph-start
This is the regular expression for recognizing the beginning of a line
that starts @emph{or} separates paragraphs.  The default value is
@w{@code{"[@ \t\n\f]"}}, which matches a line starting with a space, tab,
newline, or form feed (after its left margin).
@end defvar

@defvar sentence-end
This is the regular expression describing the end of a sentence.  (All
paragraph boundaries also end sentences, regardless.)  The default value
is:

@example
"[.?!][]\"')@}]*\\($\\| $\\|\t\\| \\)[ \t\n]*"
@end example

This means a period, question mark or exclamation mark, followed
optionally by a closing parenthetical character, followed by tabs,
spaces or new lines.

For a detailed explanation of this regular expression, see @ref{Regexp
Example}.
@end defvar
