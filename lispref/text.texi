@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
@c   Free Software Foundation, Inc. 
@c See the file elisp.texi for copying conditions.
@setfilename ../info/text
@node Text, Non-ASCII Characters, Markers, Top
@chapter Text
@cindex text

  This chapter describes the functions that deal with the text in a
buffer.  Most examine, insert, or delete text in the current buffer,
often operating at point or on text adjacent to point.  Many are
interactive.  All the functions that change the text provide for undoing
the changes (@pxref{Undo}).

  Many text-related functions operate on a region of text defined by two
buffer positions passed in arguments named @var{start} and @var{end}.
These arguments should be either markers (@pxref{Markers}) or numeric
character positions (@pxref{Positions}).  The order of these arguments
does not matter; it is all right for @var{start} to be the end of the
region and @var{end} the beginning.  For example, @code{(delete-region 1
10)} and @code{(delete-region 10 1)} are equivalent.  An
@code{args-out-of-range} error is signaled if either @var{start} or
@var{end} is outside the accessible portion of the buffer.  In an
interactive call, point and the mark are used for these arguments.

@cindex buffer contents
  Throughout this chapter, ``text'' refers to the characters in the
buffer, together with their properties (when relevant).  Keep in mind
that point is always between two characters, and the cursor appears on
the character after point.

@menu
* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Transposition::    Swapping two portions of a buffer.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Base 64::          Conversion to or from base 64 encoding.
* MD5 Checksum::     Compute the MD5 ``message digest''/``checksum''.
* Change Hooks::     Supplying functions to be run when text is changed.
@end menu

@node Near Point
@section Examining Text Near Point

  Many functions are provided to look at the characters around point.
Several simple functions are described here.  See also @code{looking-at}
in @ref{Regexp Search}.

@defun char-after &optional position
This function returns the character in the current buffer at (i.e.,
immediately after) position @var{position}.  If @var{position} is out of
range for this purpose, either before the beginning of the buffer, or at
or beyond the end, then the value is @code{nil}.  The default for
@var{position} is point.

In the following example, assume that the first character in the
buffer is @samp{@@}:

@example
@group
(char-to-string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position
This function returns the character in the current buffer immediately
before position @var{position}.  If @var{position} is out of range for
this purpose, either before the beginning of the buffer, or at or beyond
the end, then the value is @code{nil}.  The default for
@var{position} is point.
@end defun

@defun following-char
This function returns the character following point in the current
buffer.  This is similar to @code{(char-after (point))}.  However, if
point is at the end of the buffer, then @code{following-char} returns 0.

Remember that point is always between characters, and the terminal
cursor normally appears over the character following point.  Therefore,
the character returned by @code{following-char} is the character the
cursor is over.

In this example, point is between the @samp{a} and the @samp{c}.

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(char-to-string (preceding-char))
     @result{} "a"
(char-to-string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char
This function returns the character preceding point in the current
buffer.  See above, under @code{following-char}, for an example.  If
point is at the beginning of the buffer, @code{preceding-char} returns
0.
@end defun

@defun bobp
This function returns @code{t} if point is at the beginning of the
buffer.  If narrowing is in effect, this means the beginning of the
accessible portion of the text.  See also @code{point-min} in
@ref{Point}.
@end defun

@defun eobp
This function returns @code{t} if point is at the end of the buffer.
If narrowing is in effect, this means the end of accessible portion of
the text.  See also @code{point-max} in @xref{Point}.
@end defun

@defun bolp
This function returns @code{t} if point is at the beginning of a line.
@xref{Text Lines}.  The beginning of the buffer (or of its accessible
portion) always counts as the beginning of a line.
@end defun

@defun eolp
This function returns @code{t} if point is at the end of a line.  The
end of the buffer (or of its accessible portion) is always considered
the end of a line.
@end defun

@node Buffer Contents
@section Examining Buffer Contents

  This section describes two functions that allow a Lisp program to
convert any portion of the text in the buffer into a string.

@defun buffer-substring start end
This function returns a string containing a copy of the text of the
region defined by positions @var{start} and @var{end} in the current
buffer.  If the arguments are not positions in the accessible portion of
the buffer, @code{buffer-substring} signals an @code{args-out-of-range}
error.

It is not necessary for @var{start} to be less than @var{end}; the
arguments can be given in either order.  But most often the smaller
argument is written first.

If the text being copied has any text properties, these are copied into
the string along with the characters they belong to.  @xref{Text
Properties}.  However, overlays (@pxref{Overlays}) in the buffer and
their properties are ignored, not copied.

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
@result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
@result{} "he contents of buffer foo
"
@end group
@end example
@end defun

@defun buffer-substring-no-properties start end
This is like @code{buffer-substring}, except that it does not copy text
properties, just the characters themselves.  @xref{Text Properties}.
@end defun

@defun buffer-string
This function returns the contents of the entire accessible portion of
the current buffer as a string.  It is equivalent to

@example
(buffer-substring (point-min) (point-max))
@end example

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------

(buffer-string)
     @result{} "This is the contents of buffer foo
"
@end group
@end example
@end defun

@defun thing-at-point thing
Return the @var{thing} around or next to point, as a string.

The argument @var{thing} is a symbol which specifies a kind of syntactic
entity.  Possibilities include @code{symbol}, @code{list}, @code{sexp},
@code{defun}, @code{filename}, @code{url}, @code{word}, @code{sentence},
@code{whitespace}, @code{line}, @code{page}, and others.

@example
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------

(thing-at-point 'word)
     @result{} "Peace"
(thing-at-point 'line)
     @result{} "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
     @result{} nil
@end example
@end defun

@node Comparing Text
@section Comparing Text
@cindex comparing buffer text

  This function lets you compare portions of the text in a buffer, without
copying them into strings first.

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
This function lets you compare two substrings of the same buffer or two
different buffers.  The first three arguments specify one substring,
giving a buffer and two positions within the buffer.  The last three
arguments specify the other substring in the same way.  You can use
@code{nil} for @var{buffer1}, @var{buffer2}, or both to stand for the
current buffer.

The value is negative if the first substring is less, positive if the
first is greater, and zero if they are equal.  The absolute value of
the result is one plus the index of the first differing characters
within the substrings.

This function ignores case when comparing characters
if @code{case-fold-search} is non-@code{nil}.  It always ignores
text properties.

Suppose the current buffer contains the text @samp{foobarbar
haha!rara!}; then in this example the two substrings are @samp{rbar }
and @samp{rara!}.  The value is 2 because the first substring is greater
at the second character.

@example
(compare-buffer-substrings nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@section Inserting Text
@cindex insertion of text
@cindex text insertion

@cindex insertion before point
@cindex before point, insertion
  @dfn{Insertion} means adding new text to a buffer.  The inserted text
goes at point---between the character before point and the character
after point.  Some insertion functions leave point before the inserted
text, while other functions leave it after.  We call the former
insertion @dfn{after point} and the latter insertion @dfn{before point}.

  Insertion relocates markers that point at positions after the
insertion point, so that they stay with the surrounding text
(@pxref{Markers}).  When a marker points at the place of insertion,
insertion may or may not relocate the marker, depending on the marker's
insertion type (@pxref{Marker Insertion Types}).  Certain special
functions such as @code{insert-before-markers} relocate all such markers
to point after the inserted text, regardless of the markers' insertion
type.

  Insertion functions signal an error if the current buffer is
read-only or if they insert within read-only text.

  These functions copy text characters from strings and buffers along
with their properties.  The inserted characters have exactly the same
properties as the characters they were copied from.  By contrast,
characters specified as separate arguments, not part of a string or
buffer, inherit their text properties from the neighboring text.

  The insertion functions convert text from unibyte to multibyte in
order to insert in a multibyte buffer, and vice versa---if the text
comes from a string or from a buffer.  However, they do not convert
unibyte character codes 128 through 255 to multibyte characters, not
even if the current buffer is a multibyte buffer.  @xref{Converting
Representations}.

@defun insert &rest args
This function inserts the strings and/or characters @var{args} into the
current buffer, at point, moving point forward.  In other words, it
inserts the text before point.  An error is signaled unless all
@var{args} are either strings or characters.  The value is @code{nil}.
@end defun

@defun insert-before-markers &rest args
This function inserts the strings and/or characters @var{args} into the
current buffer, at point, moving point forward.  An error is signaled
unless all @var{args} are either strings or characters.  The value is
@code{nil}.

This function is unlike the other insertion functions in that it
relocates markers initially pointing at the insertion point, to point
after the inserted text.  If an overlay begins the insertion point, the
inserted text falls outside the overlay; if a nonempty overlay ends at
the insertion point, the inserted text falls inside that overlay.
@end defun

@defun insert-char character &optional count inherit
This function inserts @var{count} instances of @var{character} into the
current buffer before point.  The argument @var{count} should be a
number (@code{nil} means 1), and @var{character} must be a character.
The value is @code{nil}.

This function does not convert unibyte character codes 128 through 255
to multibyte characters, not even if the current buffer is a multibyte
buffer.  @xref{Converting Representations}.

If @var{inherit} is non-@code{nil}, then the inserted characters inherit
sticky text properties from the two characters before and after the
insertion point.  @xref{Sticky Properties}.
@end defun

@defun insert-buffer-substring from-buffer-or-name &optional start end
This function inserts a portion of buffer @var{from-buffer-or-name}
(which must already exist) into the current buffer before point.  The
text inserted is the region from @var{start} and @var{end}.  (These
arguments default to the beginning and end of the accessible portion of
that buffer.)  This function returns @code{nil}.

In this example, the form is executed with buffer @samp{bar} as the
current buffer.  We assume that buffer @samp{bar} is initially empty.

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

  @xref{Sticky Properties}, for other insertion functions that inherit
text properties from the nearby text in addition to inserting it.
Whitespace inserted by indentation functions also inherits text
properties.

@node Commands for Insertion
@section User-Level Insertion Commands

  This section describes higher-level commands for inserting text,
commands intended primarily for the user but useful also in Lisp
programs.

@deffn Command insert-buffer from-buffer-or-name
This command inserts the entire contents of @var{from-buffer-or-name}
(which must exist) into the current buffer after point.  It leaves
the mark after the inserted text.  The value is @code{nil}.
@end deffn

@deffn Command self-insert-command count
@cindex character insertion
@cindex self-insertion
This command inserts the last character typed; it does so @var{count}
times, before point, and returns @code{nil}.  Most printing characters
are bound to this command.  In routine use, @code{self-insert-command}
is the most frequently called function in Emacs, but programs rarely use
it except to install it on a keymap.

In an interactive call, @var{count} is the numeric prefix argument.

This command calls @code{auto-fill-function} whenever that is
non-@code{nil} and the character inserted is in the table
@code{auto-fill-chars} (@pxref{Auto Filling}).

@c Cross refs reworded to prevent overfull hbox.  --rjc 15mar92
This command performs abbrev expansion if Abbrev mode is enabled and
the inserted character does not have word-constituent
syntax. (@xref{Abbrevs}, and @ref{Syntax Class Table}.)

This is also responsible for calling @code{blink-paren-function} when
the inserted character has close parenthesis syntax (@pxref{Blinking}).

Do not try substituting your own definition of
@code{self-insert-command} for the standard one.  The editor command
loop handles this function specially.
@end deffn

@deffn Command newline &optional number-of-newlines 
This command inserts newlines into the current buffer before point.
If @var{number-of-newlines} is supplied, that many newline characters
are inserted.

@cindex newline and Auto Fill mode
This function calls @code{auto-fill-function} if the current column
number is greater than the value of @code{fill-column} and
@var{number-of-newlines} is @code{nil}.  Typically what
@code{auto-fill-function} does is insert a newline; thus, the overall
result in this case is to insert two newlines at different places: one
at point, and another earlier in the line.  @code{newline} does not
auto-fill if @var{number-of-newlines} is non-@code{nil}.

This command indents to the left margin if that is not zero.
@xref{Margins}.

The value returned is @code{nil}.  In an interactive call, @var{count}
is the numeric prefix argument.
@end deffn

@deffn Command split-line
This command splits the current line, moving the portion of the line
after point down vertically so that it is on the next line directly
below where it was before.  Whitespace is inserted as needed at the
beginning of the lower line, using the @code{indent-to} function.
@code{split-line} returns the position of point.

Programs hardly ever use this function.
@end deffn

@defvar overwrite-mode
This variable controls whether overwrite mode is in effect.  The value
should be @code{overwrite-mode-textual}, @code{overwrite-mode-binary},
or @code{nil}.  @code{overwrite-mode-textual} specifies textual
overwrite mode (treats newlines and tabs specially), and
@code{overwrite-mode-binary} specifies binary overwrite mode (treats
newlines and tabs like any other characters).
@end defvar

@node Deletion
@section Deleting Text

@cindex deletion vs killing
  Deletion means removing part of the text in a buffer, without saving
it in the kill ring (@pxref{The Kill Ring}).  Deleted text can't be
yanked, but can be reinserted using the undo mechanism (@pxref{Undo}).
Some deletion functions do save text in the kill ring in some special
cases.

  All of the deletion functions operate on the current buffer, and all
return a value of @code{nil}.

@deffn Command erase-buffer
This function deletes the entire text of the current buffer, leaving it
empty.  If the buffer is read-only, it signals a @code{buffer-read-only}
error; if some of the text in it is read-only, it signals a
@code{text-read-only} error.  Otherwise, it deletes the text without
asking for any confirmation.  It returns @code{nil}.

Normally, deleting a large amount of text from a buffer inhibits further
auto-saving of that buffer ``because it has shrunk''.  However,
@code{erase-buffer} does not do this, the idea being that the future
text is not really related to the former text, and its size should not
be compared with that of the former text.
@end deffn

@deffn Command delete-region start end
This command deletes the text between positions @var{start} and
@var{end} in the current buffer, and returns @code{nil}.  If point was
inside the deleted region, its value afterward is @var{start}.
Otherwise, point relocates with the surrounding text, as markers do.
@end deffn

@defun delete-and-extract-region start end
@tindex delete-and-extract-region
This function deletes the text between positions @var{start} and
@var{end} in the current buffer, and returns a string containing the
text just deleted.

If point was inside the deleted region, its value afterward is
@var{start}.  Otherwise, point relocates with the surrounding text, as
markers do.
@end defun

@deffn Command delete-char count &optional killp
This command deletes @var{count} characters directly after point, or
before point if @var{count} is negative.  If @var{killp} is
non-@code{nil}, then it saves the deleted characters in the kill ring.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@deffn Command delete-backward-char count &optional killp
@cindex delete previous char
This command deletes @var{count} characters directly before point, or
after point if @var{count} is negative.  If @var{killp} is
non-@code{nil}, then it saves the deleted characters in the kill ring.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@deffn Command backward-delete-char-untabify count &optional killp
@cindex tab deletion
This command deletes @var{count} characters backward, changing tabs
into spaces.  When the next character to be deleted is a tab, it is
first replaced with the proper number of spaces to preserve alignment
and then one of those spaces is deleted instead of the tab.  If
@var{killp} is non-@code{nil}, then the command saves the deleted
characters in the kill ring.

Conversion of tabs to spaces happens only if @var{count} is positive.
If it is negative, exactly @minus{}@var{count} characters after point
are deleted.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@defopt backward-delete-char-untabify-method
This option specifies how @code{backward-delete-char-untabify} should
deal with whitespace.  Possible values include @code{untabify}, the
default, meaning convert a tab to many spaces and delete one;
@code{hungry}, meaning delete all the whitespace characters before point
with one command, and @code{nil}, meaning do nothing special for
whitespace characters.
@end defopt

@node User-Level Deletion
@section User-Level Deletion Commands

  This section describes higher-level commands for deleting text,
commands intended primarily for the user but useful also in Lisp
programs.

@deffn Command delete-horizontal-space
@cindex deleting whitespace
This function deletes all spaces and tabs around point.  It returns
@code{nil}.

In the following examples, we call @code{delete-horizontal-space} four
times, once on each line, with point between the second and third
characters on the line each time.

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Four times.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command delete-indentation &optional join-following-p 
This function joins the line point is on to the previous line, deleting
any whitespace at the join and in some cases replacing it with one
space.  If @var{join-following-p} is non-@code{nil},
@code{delete-indentation} joins this line to the following line
instead.  The function returns @code{nil}.

If there is a fill prefix, and the second of the lines being joined
starts with the prefix, then @code{delete-indentation} deletes the
fill prefix before joining the lines.  @xref{Margins}.

In the example below, point is located on the line starting
@samp{events}, and it makes no difference if there are trailing spaces
in the preceding line.

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

After the lines are joined, the function @code{fixup-whitespace} is
responsible for deciding whether to leave a space at the junction.
@end deffn

@defun fixup-whitespace
This function replaces all the whitespace surrounding point with either
one space or no space, according to the context.  It returns @code{nil}.

At the beginning or end of a line, the appropriate amount of space is
none.  Before a character with close parenthesis syntax, or after a
character with open parenthesis or expression-prefix syntax, no space is
also appropriate.  Otherwise, one space is appropriate.  @xref{Syntax
Class Table}.

In the example below, @code{fixup-whitespace} is called the first time
with point before the word @samp{spaces} in the first line.  For the
second invocation, point is directly after the @samp{(}.

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end defun

@deffn Command just-one-space
@comment !!SourceFile simple.el
This command replaces any spaces and tabs around point with a single
space.  It returns @code{nil}.
@end deffn

@deffn Command delete-blank-lines
This function deletes blank lines surrounding point.  If point is on a
blank line with one or more blank lines before or after it, then all but
one of them are deleted.  If point is on an isolated blank line, then it
is deleted.  If point is on a nonblank line, the command deletes all
blank lines following it.

A blank line is defined as a line containing only tabs and spaces.

@code{delete-blank-lines} returns @code{nil}.
@end deffn

@node The Kill Ring
@section The Kill Ring
@cindex kill ring

  @dfn{Kill functions} delete text like the deletion functions, but save
it so that the user can reinsert it by @dfn{yanking}.  Most of these
functions have @samp{kill-} in their name.  By contrast, the functions
whose names start with @samp{delete-} normally do not save text for
yanking (though they can still be undone); these are ``deletion''
functions.

  Most of the kill commands are primarily for interactive use, and are
not described here.  What we do describe are the functions provided for
use in writing such commands.  You can use these functions to write
commands for killing text.  When you need to delete text for internal
purposes within a Lisp function, you should normally use deletion
functions, so as not to disturb the kill ring contents.
@xref{Deletion}.

  Killed text is saved for later yanking in the @dfn{kill ring}.  This
is a list that holds a number of recent kills, not just the last text
kill.  We call this a ``ring'' because yanking treats it as having
elements in a cyclic order.  The list is kept in the variable
@code{kill-ring}, and can be operated on with the usual functions for
lists; there are also specialized functions, described in this section,
that treat it as a ring.

  Some people think this use of the word ``kill'' is unfortunate, since
it refers to operations that specifically @emph{do not} destroy the
entities ``killed''.  This is in sharp contrast to ordinary life, in
which death is permanent and ``killed'' entities do not come back to
life.  Therefore, other metaphors have been proposed.  For example, the
term ``cut ring'' makes sense to people who, in pre-computer days, used
scissors and paste to cut up and rearrange manuscripts.  However, it
would be difficult to change the terminology now.

@menu
* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::	   Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill-ring data.
@end menu

@node Kill Ring Concepts
@comment  node-name,  next,  previous,  up
@subsection Kill Ring Concepts

  The kill ring records killed text as strings in a list, most recent
first.  A short kill ring, for example, might look like this:

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
When the list reaches @code{kill-ring-max} entries in length, adding a
new entry automatically deletes the last entry.

  When kill commands are interwoven with other commands, each kill
command makes a new entry in the kill ring.  Multiple kill commands in
succession build up a single kill-ring entry, which would be yanked as a
unit; the second and subsequent consecutive kill commands add text to
the entry made by the first one.

  For yanking, one entry in the kill ring is designated the ``front'' of
the ring.  Some yank commands ``rotate'' the ring by designating a
different element as the ``front.''  But this virtual rotation doesn't
change the list itself---the most recent entry always comes first in the
list.

@node Kill Functions
@comment  node-name,  next,  previous,  up
@subsection Functions for Killing

  @code{kill-region} is the usual subroutine for killing text.  Any
command that calls this function is a ``kill command'' (and should
probably have @samp{kill} in its name).  @code{kill-region} puts the
newly killed text in a new element at the beginning of the kill ring or
adds it to the most recent element.  It determines automatically (using
@code{last-command}) whether the previous command was a kill command,
and if so appends the killed text to the most recent entry.

@deffn Command kill-region start end
This function kills the text in the region defined by @var{start} and
@var{end}.  The text is deleted but saved in the kill ring, along with
its text properties.  The value is always @code{nil}.

In an interactive call, @var{start} and @var{end} are point and
the mark.

@c Emacs 19 feature
If the buffer or text is read-only, @code{kill-region} modifies the kill
ring just the same, then signals an error without modifying the buffer.
This is convenient because it lets the user use a series of kill
commands to copy text from a read-only buffer into the kill ring.
@end deffn

@defopt kill-read-only-ok
If this option is non-@code{nil}, @code{kill-region} does not signal an
error if the buffer or text is read-only.  Instead, it simply returns,
updating the kill ring but not changing the buffer.
@end defopt

@deffn Command copy-region-as-kill start end
This command saves the region defined by @var{start} and @var{end} on
the kill ring (including text properties), but does not delete the text
from the buffer.  It returns @code{nil}.  It also indicates the extent
of the text copied by moving the cursor momentarily, or by displaying a
message in the echo area.

The command does not set @code{this-command} to @code{kill-region}, so a
subsequent kill command does not append to the same kill ring entry.

Don't call @code{copy-region-as-kill} in Lisp programs unless you aim to
support Emacs 18.  For newer Emacs versions, it is better to use
@code{kill-new} or @code{kill-append} instead.  @xref{Low-Level Kill
Ring}.
@end deffn

@node Yank Commands
@comment  node-name,  next,  previous,  up
@subsection Functions for Yanking

  @dfn{Yanking} means reinserting an entry of previously killed text
from the kill ring.  The text properties are copied too.

@deffn Command yank &optional arg
@cindex inserting killed text
This command inserts before point the text in the first entry in the
kill ring.  It positions the mark at the beginning of that text, and
point at the end.

If @var{arg} is a list (which occurs interactively when the user
types @kbd{C-u} with no digits), then @code{yank} inserts the text as
described above, but puts point before the yanked text and puts the mark
after it.

If @var{arg} is a number, then @code{yank} inserts the @var{arg}th most
recently killed text---the @var{arg}th element of the kill ring list.

@code{yank} does not alter the contents of the kill ring or rotate it.
It returns @code{nil}.
@end deffn

@deffn Command yank-pop arg
This command replaces the just-yanked entry from the kill ring with a
different entry from the kill ring.

This is allowed only immediately after a @code{yank} or another
@code{yank-pop}.  At such a time, the region contains text that was just
inserted by yanking.  @code{yank-pop} deletes that text and inserts in
its place a different piece of killed text.  It does not add the deleted
text to the kill ring, since it is already in the kill ring somewhere.

If @var{arg} is @code{nil}, then the replacement text is the previous
element of the kill ring.  If @var{arg} is numeric, the replacement is
the @var{arg}th previous kill.  If @var{arg} is negative, a more recent
kill is the replacement.

The sequence of kills in the kill ring wraps around, so that after the
oldest one comes the newest one, and before the newest one goes the
oldest.

The return value is always @code{nil}.
@end deffn

@node Low-Level Kill Ring
@subsection Low-Level Kill Ring

  These functions and variables provide access to the kill ring at a
lower level, but still convenient for use in Lisp programs, because they
take care of interaction with window system selections
(@pxref{Window System Selections}).

@defun current-kill n &optional do-not-move
The function @code{current-kill} rotates the yanking pointer, which
designates the ``front'' of the kill ring, by @var{n} places (from newer
kills to older ones), and returns the text at that place in the ring.

If the optional second argument @var{do-not-move} is non-@code{nil},
then @code{current-kill} doesn't alter the yanking pointer; it just
returns the @var{n}th kill, counting from the current yanking pointer.

If @var{n} is zero, indicating a request for the latest kill,
@code{current-kill} calls the value of
@code{interprogram-paste-function} (documented below) before consulting
the kill ring.
@end defun

@defun kill-new string
This function puts the text @var{string} into the kill ring as a new
entry at the front of the ring.  It discards the oldest entry if
appropriate.  It also invokes the value of
@code{interprogram-cut-function} (see below).
@end defun

@defun kill-append string before-p
This function appends the text @var{string} to the first entry in the
kill ring.  Normally @var{string} goes at the end of the entry, but if
@var{before-p} is non-@code{nil}, it goes at the beginning.  This
function also invokes the value of @code{interprogram-cut-function} (see
below).
@end defun

@defvar interprogram-paste-function
This variable provides a way of transferring killed text from other
programs, when you are using a window system.  Its value should be
@code{nil} or a function of no arguments.

If the value is a function, @code{current-kill} calls it to get the
``most recent kill''.  If the function returns a non-@code{nil} value,
then that value is used as the ``most recent kill''.  If it returns
@code{nil}, then the first element of @code{kill-ring} is used.

The normal use of this hook is to get the window system's primary
selection as the most recent kill, even if the selection belongs to
another application.  @xref{Window System Selections}.
@end defvar

@defvar interprogram-cut-function
This variable provides a way of communicating killed text to other
programs, when you are using a window system.  Its value should be
@code{nil} or a function of one argument.

If the value is a function, @code{kill-new} and @code{kill-append} call
it with the new first element of the kill ring as an argument.

The normal use of this hook is to set the window system's primary
selection from the newly killed text.  @xref{Window System Selections}.
@end defvar

@node Internals of Kill Ring
@comment  node-name,  next,  previous,  up
@subsection Internals of the Kill Ring

  The variable @code{kill-ring} holds the kill ring contents, in the
form of a list of strings.  The most recent kill is always at the front
of the list. 

  The @code{kill-ring-yank-pointer} variable points to a link in the
kill ring list, whose @sc{car} is the text to yank next.  We say it
identifies the ``front'' of the ring.  Moving
@code{kill-ring-yank-pointer} to a different link is called
@dfn{rotating the kill ring}.  We call the kill ring a ``ring'' because
the functions that move the yank pointer wrap around from the end of the
list to the beginning, or vice-versa.  Rotation of the kill ring is
virtual; it does not change the value of @code{kill-ring}.

  Both @code{kill-ring} and @code{kill-ring-yank-pointer} are Lisp
variables whose values are normally lists.  The word ``pointer'' in the
name of the @code{kill-ring-yank-pointer} indicates that the variable's
purpose is to identify one element of the list for use by the next yank
command.

  The value of @code{kill-ring-yank-pointer} is always @code{eq} to one
of the links in the kill ring list.  The element it identifies is the
@sc{car} of that link.  Kill commands, which change the kill ring, also
set this variable to the value of @code{kill-ring}.  The effect is to
rotate the ring so that the newly killed text is at the front.

  Here is a diagram that shows the variable @code{kill-ring-yank-pointer}
pointing to the second entry in the kill ring @code{("some text" "a
different piece of text" "yet older text")}.  

@example
@group
kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --> |   |   |------> |   |   |--> |   |   |--> nil
        --- ---          --- ---      --- ---
         |                |            |            
         |                |            |            
         |                |             -->"yet older text" 
         |                |
         |                 --> "a different piece of text" 
         |
          --> "some text"
@end group
@end example

@noindent
This state of affairs might occur after @kbd{C-y} (@code{yank})
immediately followed by @kbd{M-y} (@code{yank-pop}).

@defvar kill-ring
This variable holds the list of killed text sequences, most recently
killed first.
@end defvar

@defvar kill-ring-yank-pointer
This variable's value indicates which element of the kill ring is at the
``front'' of the ring for yanking.  More precisely, the value is a tail
of the value of @code{kill-ring}, and its @sc{car} is the kill string
that @kbd{C-y} should yank.
@end defvar

@defopt kill-ring-max
The value of this variable is the maximum length to which the kill
ring can grow, before elements are thrown away at the end.  The default
value for @code{kill-ring-max} is 30.
@end defopt

@node Undo
@comment  node-name,  next,  previous,  up
@section Undo
@cindex redo

  Most buffers have an @dfn{undo list}, which records all changes made
to the buffer's text so that they can be undone.  (The buffers that
don't have one are usually special-purpose buffers for which Emacs
assumes that undoing is not useful.)  All the primitives that modify the
text in the buffer automatically add elements to the front of the undo
list, which is in the variable @code{buffer-undo-list}.

@defvar buffer-undo-list
This variable's value is the undo list of the current buffer.
A value of @code{t} disables the recording of undo information.
@end defvar

Here are the kinds of elements an undo list can have:

@table @code
@item @var{position}
This kind of element records a previous value of point; undoing this
element moves point to @var{position}.  Ordinary cursor motion does not
make any sort of undo record, but deletion operations use these entries
to record where point was before the command.

@item (@var{beg} . @var{end})
This kind of element indicates how to delete text that was inserted.
Upon insertion, the text occupied the range @var{beg}--@var{end} in the 
buffer.

@item (@var{text} . @var{position})
This kind of element indicates how to reinsert text that was deleted.
The deleted text itself is the string @var{text}.  The place to
reinsert it is @code{(abs @var{position})}.

@item (t @var{high} . @var{low})
This kind of element indicates that an unmodified buffer became
modified.  The elements @var{high} and @var{low} are two integers, each
recording 16 bits of the visited file's modification time as of when it
was previously visited or saved.  @code{primitive-undo} uses those
values to determine whether to mark the buffer as unmodified once again;
it does so only if the file's modification time matches those numbers.

@item (nil @var{property} @var{value} @var{beg} . @var{end})
This kind of element records a change in a text property.
Here's how you might undo the change:

@example
(put-text-property @var{beg} @var{end} @var{property} @var{value})
@end example

@item (@var{marker} . @var{adjustment})
This kind of element records the fact that the marker @var{marker} was
relocated due to deletion of surrounding text, and that it moved
@var{adjustment} character positions.  Undoing this element moves
@var{marker} @minus{} @var{adjustment} characters.

@item nil
This element is a boundary.  The elements between two boundaries are
called a @dfn{change group}; normally, each change group corresponds to
one keyboard command, and undo commands normally undo an entire group as
a unit.
@end table

@defun undo-boundary
This function places a boundary element in the undo list.  The undo
command stops at such a boundary, and successive undo commands undo
to earlier and earlier boundaries.  This function returns @code{nil}.

The editor command loop automatically creates an undo boundary before
each key sequence is executed.  Thus, each undo normally undoes the
effects of one command.  Self-inserting input characters are an
exception.  The command loop makes a boundary for the first such
character; the next 19 consecutive self-inserting input characters do
not make boundaries, and then the 20th does, and so on as long as
self-inserting characters continue.

All buffer modifications add a boundary whenever the previous undoable
change was made in some other buffer.  This is to ensure that
each command makes a boundary in each buffer where it makes changes.

Calling this function explicitly is useful for splitting the effects of
a command into more than one unit.  For example, @code{query-replace}
calls @code{undo-boundary} after each replacement, so that the user can
undo individual replacements one by one.
@end defun

@defun primitive-undo count list
This is the basic function for undoing elements of an undo list.
It undoes the first @var{count} elements of @var{list}, returning
the rest of @var{list}.  You could write this function in Lisp,
but it is convenient to have it in C.

@code{primitive-undo} adds elements to the buffer's undo list when it
changes the buffer.  Undo commands avoid confusion by saving the undo
list value at the beginning of a sequence of undo operations.  Then the
undo operations use and update the saved value.  The new elements added
by undoing are not part of this saved value, so they don't interfere with
continuing to undo.
@end defun

@node Maintaining Undo
@section Maintaining Undo Lists

  This section describes how to enable and disable undo information for
a given buffer.  It also explains how the undo list is truncated
automatically so it doesn't get too big.

  Recording of undo information in a newly created buffer is normally
enabled to start with; but if the buffer name starts with a space, the
undo recording is initially disabled.  You can explicitly enable or
disable undo recording with the following two functions, or by setting
@code{buffer-undo-list} yourself.

@deffn Command buffer-enable-undo &optional buffer-or-name
This command enables recording undo information for buffer
@var{buffer-or-name}, so that subsequent changes can be undone.  If no
argument is supplied, then the current buffer is used.  This function
does nothing if undo recording is already enabled in the buffer.  It
returns @code{nil}.

In an interactive call, @var{buffer-or-name} is the current buffer.
You cannot specify any other buffer.
@end deffn

@deffn Command buffer-disable-undo &optional buffer
@deffnx Command buffer-flush-undo &optional buffer
@cindex disable undo
This function discards the undo list of @var{buffer}, and disables
further recording of undo information.  As a result, it is no longer
possible to undo either previous changes or any subsequent changes.  If
the undo list of @var{buffer} is already disabled, this function
has no effect.

This function returns @code{nil}.

The name @code{buffer-flush-undo} is not considered obsolete, but the
preferred name is @code{buffer-disable-undo}.
@end deffn

  As editing continues, undo lists get longer and longer.  To prevent
them from using up all available memory space, garbage collection trims
them back to size limits you can set.  (For this purpose, the ``size''
of an undo list measures the cons cells that make up the list, plus the
strings of deleted text.)  Two variables control the range of acceptable
sizes: @code{undo-limit} and @code{undo-strong-limit}.

@defvar undo-limit
This is the soft limit for the acceptable size of an undo list.  The
change group at which this size is exceeded is the last one kept.
@end defvar

@defvar undo-strong-limit
This is the upper limit for the acceptable size of an undo list.  The
change group at which this size is exceeded is discarded itself (along
with all older change groups).  There is one exception: the very latest
change group is never discarded no matter how big it is.
@end defvar

@node Filling
@comment  node-name,  next,  previous,  up
@section Filling
@cindex filling, explicit

  @dfn{Filling} means adjusting the lengths of lines (by moving the line
breaks) so that they are nearly (but no greater than) a specified
maximum width.  Additionally, lines can be @dfn{justified}, which means
inserting spaces to make the left and/or right margins line up
precisely.  The width is controlled by the variable @code{fill-column}.
For ease of reading, lines should be no longer than 70 or so columns.

  You can use Auto Fill mode (@pxref{Auto Filling}) to fill text
automatically as you insert it, but changes to existing text may leave
it improperly filled.  Then you must fill the text explicitly.

  Most of the commands in this section return values that are not
meaningful.  All the functions that do filling take note of the current
left margin, current right margin, and current justification style
(@pxref{Margins}).  If the current justification style is
@code{none}, the filling functions don't actually do anything.

  Several of the filling functions have an argument @var{justify}.
If it is non-@code{nil}, that requests some kind of justification.  It
can be @code{left}, @code{right}, @code{full}, or @code{center}, to
request a specific style of justification.  If it is @code{t}, that
means to use the current justification style for this part of the text
(see @code{current-justification}, below).  Any other value is treated
as @code{full}.

  When you call the filling functions interactively, using a prefix
argument implies the value @code{full} for @var{justify}.

@deffn Command fill-paragraph justify
@cindex filling a paragraph
This command fills the paragraph at or after point.  If
@var{justify} is non-@code{nil}, each line is justified as well.
It uses the ordinary paragraph motion commands to find paragraph
boundaries.  @xref{Paragraphs,,, emacs, The GNU Emacs Manual}.
@end deffn

@deffn Command fill-region start end &optional justify nosqueeze to-eop
This command fills each of the paragraphs in the region from @var{start}
to @var{end}.  It justifies as well if @var{justify} is
non-@code{nil}.

If @var{nosqueeze} is non-@code{nil}, that means to leave whitespace
other than line breaks untouched.  If @var{to-eop} is non-@code{nil},
that means to keep filling to the end of the paragraph---or the next hard
newline, if @code{use-hard-newlines} is enabled (see below).

The variable @code{paragraph-separate} controls how to distinguish
paragraphs.  @xref{Standard Regexps}.
@end deffn

@deffn Command fill-individual-paragraphs start end &optional justify citation-regexp
This command fills each paragraph in the region according to its
individual fill prefix.  Thus, if the lines of a paragraph were indented
with spaces, the filled paragraph will remain indented in the same
fashion.

The first two arguments, @var{start} and @var{end}, are the beginning
and end of the region to be filled.  The third and fourth arguments,
@var{justify} and @var{citation-regexp}, are optional.  If
@var{justify} is non-@code{nil}, the paragraphs are justified as
well as filled.  If @var{citation-regexp} is non-@code{nil}, it means the
function is operating on a mail message and therefore should not fill
the header lines.  If @var{citation-regexp} is a string, it is used as
a regular expression; if it matches the beginning of a line, that line
is treated as a citation marker.

Ordinarily, @code{fill-individual-paragraphs} regards each change in
indentation as starting a new paragraph.  If
@code{fill-individual-varying-indent} is non-@code{nil}, then only
separator lines separate paragraphs.  That mode can handle indented
paragraphs with additional indentation on the first line.
@end deffn

@defopt fill-individual-varying-indent
This variable alters the action of @code{fill-individual-paragraphs} as
described above.
@end defopt

@deffn Command fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
This command considers a region of text as a single paragraph and fills
it.  If the region was made up of many paragraphs, the blank lines
between paragraphs are removed.  This function justifies as well as
filling when @var{justify} is non-@code{nil}.

In an interactive call, any prefix argument requests justification.

If @var{nosqueeze} is non-@code{nil}, that means to leave whitespace
other than line breaks untouched.  If @var{squeeze-after} is
non-@code{nil}, it specifies a position in the region, and means don't
canonicalize spaces before that position.

In Adaptive Fill mode, this command calls @code{fill-context-prefix} to
choose a fill prefix by default.  @xref{Adaptive Fill}.
@end deffn

@deffn Command justify-current-line &optional how eop nosqueeze
This command inserts spaces between the words of the current line so
that the line ends exactly at @code{fill-column}.  It returns
@code{nil}.

The argument @var{how}, if non-@code{nil} specifies explicitly the style
of justification.  It can be @code{left}, @code{right}, @code{full},
@code{center}, or @code{none}.  If it is @code{t}, that means to do
follow specified justification style (see @code{current-justification},
below).  @code{nil} means to do full justification.

If @var{eop} is non-@code{nil}, that means do left-justification if
@code{current-justification} specifies full justification.  This is used
for the last line of a paragraph; even if the paragraph as a whole is
fully justified, the last line should not be.

If @var{nosqueeze} is non-@code{nil}, that means do not change interior
whitespace.
@end deffn

@defopt default-justification
This variable's value specifies the style of justification to use for
text that doesn't specify a style with a text property.  The possible
values are @code{left}, @code{right}, @code{full}, @code{center}, or
@code{none}.  The default value is @code{left}.
@end defopt

@defun current-justification
This function returns the proper justification style to use for filling
the text around point.
@end defun

@defopt sentence-end-double-space
If this variable is non-@code{nil}, a period followed by just one space
does not count as the end of a sentence, and the filling functions
avoid breaking the line at such a place.
@end defopt

@defvar fill-paragraph-function
This variable provides a way for major modes to override the filling of
paragraphs.  If the value is non-@code{nil}, @code{fill-paragraph} calls
this function to do the work.  If the function returns a non-@code{nil}
value, @code{fill-paragraph} assumes the job is done, and immediately
returns that value.

The usual use of this feature is to fill comments in programming
language modes.  If the function needs to fill a paragraph in the usual
way, it can do so as follows:

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar use-hard-newlines
If this variable is non-@code{nil}, the filling functions do not delete
newlines that have the @code{hard} text property.  These ``hard
newlines'' act as paragraph separators.
@end defvar

@node Margins
@section Margins for Filling

@defopt fill-prefix
This buffer-local variable specifies a string of text that appears at
the beginning
of normal text lines and should be disregarded when filling them.  Any
line that fails to start with the fill prefix is considered the start of
a paragraph; so is any line that starts with the fill prefix followed by
additional whitespace.  Lines that start with the fill prefix but no
additional whitespace are ordinary text lines that can be filled
together.  The resulting filled lines also start with the fill prefix.

The fill prefix follows the left margin whitespace, if any.
@end defopt

@defopt fill-column
This buffer-local variable specifies the maximum width of filled lines.
Its value should be an integer, which is a number of columns.  All the
filling, justification, and centering commands are affected by this
variable, including Auto Fill mode (@pxref{Auto Filling}).

As a practical matter, if you are writing text for other people to
read, you should set @code{fill-column} to no more than 70.  Otherwise
the line will be too long for people to read comfortably, and this can
make the text seem clumsy.
@end defopt

@defvar default-fill-column
The value of this variable is the default value for @code{fill-column} in
buffers that do not override it.  This is the same as
@code{(default-value 'fill-column)}.

The default value for @code{default-fill-column} is 70.
@end defvar

@deffn Command set-left-margin from to margin
This sets the @code{left-margin} property on the text from @var{from} to
@var{to} to the value @var{margin}.  If Auto Fill mode is enabled, this
command also refills the region to fit the new margin.
@end deffn

@deffn Command set-right-margin from to margin
This sets the @code{right-margin} property on the text from @var{from}
to @var{to} to the value @var{margin}.  If Auto Fill mode is enabled,
this command also refills the region to fit the new margin.
@end deffn

@defun current-left-margin
This function returns the proper left margin value to use for filling
the text around point.  The value is the sum of the @code{left-margin}
property of the character at the start of the current line (or zero if
none), and the value of the variable @code{left-margin}.
@end defun

@defun current-fill-column
This function returns the proper fill column value to use for filling
the text around point.  The value is the value of the @code{fill-column}
variable, minus the value of the @code{right-margin} property of the
character after point.
@end defun

@deffn Command move-to-left-margin &optional n force
This function moves point to the left margin of the current line.  The
column moved to is determined by calling the function
@code{current-left-margin}.  If the argument @var{n} is non-@code{nil},
@code{move-to-left-margin} moves forward @var{n}@minus{}1 lines first.

If @var{force} is non-@code{nil}, that says to fix the line's
indentation if that doesn't match the left margin value.
@end deffn

@defun delete-to-left-margin &optional from to
This function removes left margin indentation from the text between
@var{from} and @var{to}.  The amount of indentation to delete is
determined by calling @code{current-left-margin}.  In no case does this
function delete non-whitespace.  If @var{from} and @var{to} are omitted,
they default to the whole buffer.
@end defun

@defun indent-to-left-margin
This is the default @code{indent-line-function}, used in Fundamental
mode, Text mode, etc.  Its effect is to adjust the indentation at the
beginning of the current line to the value specified by the variable
@code{left-margin}.  This may involve either inserting or deleting
whitespace.
@end defun

@defvar left-margin
This variable specifies the base left margin column.  In Fundamental
mode, @kbd{C-j} indents to this column.  This variable automatically
becomes buffer-local when set in any fashion.
@end defvar

@defvar fill-nobreak-predicate
This variable gives major modes a way to specify not to break a line at
certain places.  Its value should be a function.  This function is
called during filling, with no arguments and with point located at the
place where a break is being considered.  If the function returns
non-@code{nil}, then the line won't be broken there.
@end defvar

@node Adaptive Fill
@section Adaptive Fill Mode
@cindex Adaptive Fill mode

  Adaptive Fill mode chooses a fill prefix automatically from the text
in each paragraph being filled.

@defopt adaptive-fill-mode
Adaptive Fill mode is enabled when this variable is non-@code{nil}.
It is @code{t} by default.
@end defopt

@defun fill-context-prefix from to
This function implements the heart of Adaptive Fill mode; it chooses a
fill prefix based on the text between @var{from} and @var{to}.  It does
this by looking at the first two lines of the paragraph, based on the
variables described below.
@c The optional argument first-line-regexp is not documented
@c because it exists for internal purposes and might be eliminated
@c in the future.
@end defun

@defopt adaptive-fill-regexp
This variable holds a regular expression to control Adaptive Fill mode.
Adaptive Fill mode matches this regular expression against the text
starting after the left margin whitespace (if any) on a line; the
characters it matches are that line's candidate for the fill prefix.
@end defopt

@defopt adaptive-fill-first-line-regexp
In a one-line paragraph, if the candidate fill prefix matches this
regular expression, or if it matches @code{comment-start-skip}, then it
is used---otherwise, spaces amounting to the same width are used
instead.

However, the fill prefix is never taken from a one-line paragraph
if it would act as a paragraph starter on subsequent lines.
@end defopt

@defopt adaptive-fill-function
You can specify more complex ways of choosing a fill prefix
automatically by setting this variable to a function.  The function is
called when @code{adaptive-fill-regexp} does not match, with point after
the left margin of a line, and it should return the appropriate fill
prefix based on that line.  If it returns @code{nil}, that means it sees
no fill prefix in that line.
@end defopt

@node Auto Filling
@comment  node-name,  next,  previous,  up
@section Auto Filling
@cindex filling, automatic
@cindex Auto Fill mode

  Auto Fill mode is a minor mode that fills lines automatically as text
is inserted.  This section describes the hook used by Auto Fill mode.
For a description of functions that you can call explicitly to fill and
justify existing text, see @ref{Filling}.

  Auto Fill mode also enables the functions that change the margins and
justification style to refill portions of the text.  @xref{Margins}.

@defvar auto-fill-function
The value of this variable should be a function (of no arguments) to be
called after self-inserting a character from the table
@code{auto-fill-chars}.  It may be @code{nil}, in which case nothing
special is done in that case.

The value of @code{auto-fill-function} is @code{do-auto-fill} when
Auto-Fill mode is enabled.  That is a function whose sole purpose is to
implement the usual strategy for breaking a line.

@quotation
In older Emacs versions, this variable was named @code{auto-fill-hook},
but since it is not called with the standard convention for hooks, it
was renamed to @code{auto-fill-function} in version 19.
@end quotation
@end defvar

@defvar normal-auto-fill-function
This variable specifies the function to use for
@code{auto-fill-function}, if and when Auto Fill is turned on.  Major
modes can set buffer-local values for this variable to alter how Auto
Fill works.
@end defvar

@defvar auto-fill-chars
A char table of characters which invoke @code{auto-fill-function} when
self-inserted---space and newline in most language environments.  They
have an entry @code{t} in the table.
@end defvar

@node Sorting
@section Sorting Text
@cindex sorting text

  The sorting functions described in this section all rearrange text in
a buffer.  This is in contrast to the function @code{sort}, which
rearranges the order of the elements of a list (@pxref{Rearrangement}).
The values returned by these functions are not meaningful.

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun
This function is the general text-sorting routine that subdivides a
buffer into records and then sorts them.  Most of the commands in this
section use this function.

To understand how @code{sort-subr} works, consider the whole accessible
portion of the buffer as being divided into disjoint pieces called
@dfn{sort records}.  The records may or may not be contiguous, but they
must not overlap.  A portion of each sort record (perhaps all of it) is
designated as the sort key.  Sorting rearranges the records in order by
their sort keys.

Usually, the records are rearranged in order of ascending sort key.
If the first argument to the @code{sort-subr} function, @var{reverse},
is non-@code{nil}, the sort records are rearranged in order of
descending sort key.

The next four arguments to @code{sort-subr} are functions that are
called to move point across a sort record.  They are called many times
from within @code{sort-subr}.

@enumerate
@item
@var{nextrecfun} is called with point at the end of a record.  This
function moves point to the start of the next record.  The first record
is assumed to start at the position of point when @code{sort-subr} is
called.  Therefore, you should usually move point to the beginning of
the buffer before calling @code{sort-subr}.

This function can indicate there are no more sort records by leaving
point at the end of the buffer.

@item
@var{endrecfun} is called with point within a record.  It moves point to
the end of the record.

@item
@var{startkeyfun} is called to move point from the start of a record to
the start of the sort key.  This argument is optional; if it is omitted,
the whole record is the sort key.  If supplied, the function should
either return a non-@code{nil} value to be used as the sort key, or
return @code{nil} to indicate that the sort key is in the buffer
starting at point.  In the latter case, @var{endkeyfun} is called to
find the end of the sort key.

@item
@var{endkeyfun} is called to move point from the start of the sort key
to the end of the sort key.  This argument is optional.  If
@var{startkeyfun} returns @code{nil} and this argument is omitted (or
@code{nil}), then the sort key extends to the end of the record.  There
is no need for @var{endkeyfun} if @var{startkeyfun} returns a
non-@code{nil} value.
@end enumerate

As an example of @code{sort-subr}, here is the complete function
definition for @code{sort-lines}:

@example
@group
;; @r{Note that the first two lines of doc string}
;; @r{are effectively one line when viewed by a user.}
(defun sort-lines (reverse beg end)
  "Sort lines in region alphabetically;\
 argument means descending order.
Called from a program, there are three arguments:
@end group
@group
REVERSE (non-nil means reverse order),\
 BEG and END (region to sort).
The variable `sort-fold-case' determines\
 whether alphabetic case affects
the sort order.
@end group
@group
  (interactive "P\nr")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (sort-subr reverse 'forward-line 'end-of-line))))
@end group
@end example

Here @code{forward-line} moves point to the start of the next record,
and @code{end-of-line} moves point to the end of record.  We do not pass
the arguments @var{startkeyfun} and @var{endkeyfun}, because the entire
record is used as the sort key.

The @code{sort-paragraphs} function is very much the same, except that
its @code{sort-subr} call looks like this:

@example
@group
(sort-subr reverse
           (function
             (lambda ()
               (while (and (not (eobp))
                      (looking-at paragraph-separate))
                 (forward-line 1))))
           'forward-paragraph)
@end group
@end example

Markers pointing into any sort records are left with no useful
position after @code{sort-subr} returns.
@end defun

@defopt sort-fold-case
If this variable is non-@code{nil}, @code{sort-subr} and the other
buffer sorting functions ignore case when comparing strings.
@end defopt

@deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
This command sorts the region between @var{start} and @var{end}
alphabetically as specified by @var{record-regexp} and @var{key-regexp}.
If @var{reverse} is a negative integer, then sorting is in reverse
order.

Alphabetical sorting means that two sort keys are compared by
comparing the first characters of each, the second characters of each,
and so on.  If a mismatch is found, it means that the sort keys are
unequal; the sort key whose character is less at the point of first
mismatch is the lesser sort key.  The individual characters are compared
according to their numerical character codes in the Emacs character set.

The value of the @var{record-regexp} argument specifies how to divide
the buffer into sort records.  At the end of each record, a search is
done for this regular expression, and the text that matches it is taken
as the next record.  For example, the regular expression @samp{^.+$},
which matches lines with at least one character besides a newline, would
make each such line into a sort record.  @xref{Regular Expressions}, for
a description of the syntax and meaning of regular expressions.

The value of the @var{key-regexp} argument specifies what part of each
record is the sort key.  The @var{key-regexp} could match the whole
record, or only a part.  In the latter case, the rest of the record has
no effect on the sorted order of records, but it is carried along when
the record moves to its new position.

The @var{key-regexp} argument can refer to the text matched by a
subexpression of @var{record-regexp}, or it can be a regular expression
on its own.

If @var{key-regexp} is:

@table @asis
@item @samp{\@var{digit}}
then the text matched by the @var{digit}th @samp{\(...\)} parenthesis
grouping in @var{record-regexp} is the sort key.

@item @samp{\&}
then the whole record is the sort key.

@item a regular expression
then @code{sort-regexp-fields} searches for a match for the regular
expression within the record.  If such a match is found, it is the sort
key.  If there is no match for @var{key-regexp} within a record then
that record is ignored, which means its position in the buffer is not
changed.  (The other records may move around it.)
@end table

For example, if you plan to sort all the lines in the region by the
first word on each line starting with the letter @samp{f}, you should
set @var{record-regexp} to @samp{^.*$} and set @var{key-regexp} to
@samp{\<f\w*\>}.  The resulting expression looks like this:

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

If you call @code{sort-regexp-fields} interactively, it prompts for
@var{record-regexp} and @var{key-regexp} in the minibuffer.
@end deffn

@deffn Command sort-lines reverse start end
This command alphabetically sorts lines in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-paragraphs reverse start end
This command alphabetically sorts paragraphs in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-pages reverse start end
This command alphabetically sorts pages in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-fields field start end
This command sorts lines in the region between @var{start} and
@var{end}, comparing them alphabetically by the @var{field}th field
of each line.  Fields are separated by whitespace and numbered starting
from 1.  If @var{field} is negative, sorting is by the
@w{@minus{}@var{field}th} field from the end of the line.  This command
is useful for sorting tables.
@end deffn

@deffn Command sort-numeric-fields field start end
This command sorts lines in the region between @var{start} and
@var{end}, comparing them numerically by the @var{field}th field of each
line.  The specified field must contain a number in each line of the
region.  Fields are separated by whitespace and numbered starting from
1.  If @var{field} is negative, sorting is by the
@w{@minus{}@var{field}th} field from the end of the line.  This command
is useful for sorting tables.
@end deffn

@deffn Command sort-columns reverse &optional beg end
This command sorts the lines in the region between @var{beg} and
@var{end}, comparing them alphabetically by a certain range of columns.
The column positions of @var{beg} and @var{end} bound the range of
columns to sort on.

If @var{reverse} is non-@code{nil}, the sort is in reverse order.

One unusual thing about this command is that the entire line
containing position @var{beg}, and the entire line containing position
@var{end}, are included in the region sorted.

Note that @code{sort-columns} uses the @code{sort} utility program,
and so cannot work properly on text containing tab characters.  Use
@kbd{M-x untabify} to convert tabs to spaces before sorting.
@end deffn

@node Columns
@comment  node-name,  next,  previous,  up
@section Counting Columns
@cindex columns
@cindex counting columns
@cindex horizontal position

  The column functions convert between a character position (counting
characters from the beginning of the buffer) and a column position
(counting screen characters from the beginning of a line).

  These functions count each character according to the number of
columns it occupies on the screen.  This means control characters count
as occupying 2 or 4 columns, depending upon the value of
@code{ctl-arrow}, and tabs count as occupying a number of columns that
depends on the value of @code{tab-width} and on the column where the tab
begins.  @xref{Usual Display}.

  Column number computations ignore the width of the window and the
amount of horizontal scrolling.  Consequently, a column value can be
arbitrarily high.  The first (or leftmost) column is numbered 0.

@defun current-column
This function returns the horizontal position of point, measured in
columns, counting from 0 at the left margin.  The column position is the
sum of the widths of all the displayed representations of the characters
between the start of the current line and point.

For an example of using @code{current-column}, see the description of
@code{count-lines} in @ref{Text Lines}.
@end defun

@defun move-to-column column &optional force
This function moves point to @var{column} in the current line.  The
calculation of @var{column} takes into account the widths of the
displayed representations of the characters between the start of the
line and point.

If column @var{column} is beyond the end of the line, point moves to the
end of the line.  If @var{column} is negative, point moves to the
beginning of the line.

If it is impossible to move to column @var{column} because that is in
the middle of a multicolumn character such as a tab, point moves to the
end of that character.  However, if @var{force} is non-@code{nil}, and
@var{column} is in the middle of a tab, then @code{move-to-column}
converts the tab into spaces so that it can move precisely to column
@var{column}.  Other multicolumn characters can cause anomalies despite
@var{force}, since there is no way to split them.

The argument @var{force} also has an effect if the line isn't long
enough to reach column @var{column}; if it is @code{t}, that means to
add whitespace at the end of the line to reach that column.

If @var{column} is not an integer, an error is signaled.

The return value is the column number actually moved to.
@end defun

@node Indentation
@section Indentation
@cindex indentation

  The indentation functions are used to examine, move to, and change
whitespace that is at the beginning of a line.  Some of the functions
can also change whitespace elsewhere on a line.  Columns and indentation
count from zero at the left margin.

@menu
* Primitive Indent::      Functions used to count and insert indentation.
* Mode-Specific Indent::  Customize indentation for different modes.
* Region Indent::         Indent all the lines in a region.
* Relative Indent::       Indent the current line based on previous lines.
* Indent Tabs::           Adjustable, typewriter-like tab stops.
* Motion by Indent::      Move to first non-blank character.
@end menu

@node Primitive Indent
@subsection Indentation Primitives

  This section describes the primitive functions used to count and
insert indentation.  The functions in the following sections use these
primitives.  @xref{Width}, for related functions.

@defun current-indentation
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
This function returns the indentation of the current line, which is
the horizontal position of the first nonblank character.  If the
contents are entirely blank, then this is the horizontal position of the
end of the line.
@end defun

@deffn Command indent-to column &optional minimum
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
This function indents from point with tabs and spaces until @var{column}
is reached.  If @var{minimum} is specified and non-@code{nil}, then at
least that many spaces are inserted even if this requires going beyond
@var{column}.  Otherwise the function does nothing if point is already
beyond @var{column}.  The value is the column at which the inserted
indentation ends.

The inserted whitespace characters inherit text properties from the
surrounding text (usually, from the preceding text only).  @xref{Sticky
Properties}.
@end deffn

@defopt indent-tabs-mode
@comment !!SourceFile indent.c
If this variable is non-@code{nil}, indentation functions can insert
tabs as well as spaces.  Otherwise, they insert only spaces.  Setting
this variable automatically makes it buffer-local in the current buffer.
@end defopt

@node Mode-Specific Indent
@subsection Indentation Controlled by Major Mode

  An important function of each major mode is to customize the @key{TAB}
key to indent properly for the language being edited.  This section
describes the mechanism of the @key{TAB} key and how to control it.
The functions in this section return unpredictable values.

@defvar indent-line-function
This variable's value is the function to be used by @key{TAB} (and
various commands) to indent the current line.  The command
@code{indent-according-to-mode} does no more than call this function.

In Lisp mode, the value is the symbol @code{lisp-indent-line}; in C
mode, @code{c-indent-line}; in Fortran mode, @code{fortran-indent-line}.
In Fundamental mode, Text mode, and many other modes with no standard
for indentation, the value is @code{indent-to-left-margin} (which is the
default value).
@end defvar

@deffn Command indent-according-to-mode
This command calls the function in @code{indent-line-function} to
indent the current line in a way appropriate for the current major mode.
@end deffn

@deffn Command indent-for-tab-command
This command calls the function in @code{indent-line-function} to indent
the current line; however, if that function is
@code{indent-to-left-margin}, @code{insert-tab} is called instead.  (That
is a trivial command that inserts a tab character.)
@end deffn

@deffn Command newline-and-indent
@comment !!SourceFile simple.el
This function inserts a newline, then indents the new line (the one
following the newline just inserted) according to the major mode.

It does indentation by calling the current @code{indent-line-function}.
In programming language modes, this is the same thing @key{TAB} does,
but in some text modes, where @key{TAB} inserts a tab,
@code{newline-and-indent} indents to the column specified by
@code{left-margin}.
@end deffn

@deffn Command reindent-then-newline-and-indent
@comment !!SourceFile simple.el
This command reindents the current line, inserts a newline at point,
and then indents the new line (the one following the newline just
inserted).

This command does indentation on both lines according to the current
major mode, by calling the current value of @code{indent-line-function}.
In programming language modes, this is the same thing @key{TAB} does,
but in some text modes, where @key{TAB} inserts a tab,
@code{reindent-then-newline-and-indent} indents to the column specified
by @code{left-margin}.
@end deffn

@node Region Indent
@subsection Indenting an Entire Region

  This section describes commands that indent all the lines in the
region.  They return unpredictable values.

@deffn Command indent-region start end to-column
This command indents each nonblank line starting between @var{start}
(inclusive) and @var{end} (exclusive).  If @var{to-column} is
@code{nil}, @code{indent-region} indents each nonblank line by calling
the current mode's indentation function, the value of
@code{indent-line-function}.

If @var{to-column} is non-@code{nil}, it should be an integer
specifying the number of columns of indentation; then this function
gives each line exactly that much indentation, by either adding or
deleting whitespace.

If there is a fill prefix, @code{indent-region} indents each line
by making it start with the fill prefix.
@end deffn

@defvar indent-region-function
The value of this variable is a function that can be used by
@code{indent-region} as a short cut.  It should take two arguments, the
start and end of the region.  You should design the function so
that it will produce the same results as indenting the lines of the
region one by one, but presumably faster.

If the value is @code{nil}, there is no short cut, and
@code{indent-region} actually works line by line.

A short-cut function is useful in modes such as C mode and Lisp mode,
where the @code{indent-line-function} must scan from the beginning of
the function definition: applying it to each line would be quadratic in
time.  The short cut can update the scan information as it moves through
the lines indenting them; this takes linear time.  In a mode where
indenting a line individually is fast, there is no need for a short cut.

@code{indent-region} with a non-@code{nil} argument @var{to-column} has
a different meaning and does not use this variable.
@end defvar

@deffn Command indent-rigidly start end count
@comment !!SourceFile indent.el
This command indents all lines starting between @var{start}
(inclusive) and @var{end} (exclusive) sideways by @var{count} columns.
This ``preserves the shape'' of the affected region, moving it as a
rigid unit.  Consequently, this command is useful not only for indenting
regions of unindented text, but also for indenting regions of formatted
code.

For example, if @var{count} is 3, this command adds 3 columns of
indentation to each of the lines beginning in the region specified.

In Mail mode, @kbd{C-c C-y} (@code{mail-yank-original}) uses
@code{indent-rigidly} to indent the text copied from the message being
replied to.
@end deffn

@defun indent-code-rigidly start end columns &optional nochange-regexp
This is like @code{indent-rigidly}, except that it doesn't alter lines
that start within strings or comments.

In addition, it doesn't alter a line if @var{nochange-regexp} matches at
the beginning of the line (if @var{nochange-regexp} is non-@code{nil}).
@end defun

@node Relative Indent
@subsection Indentation Relative to Previous Lines

  This section describes two commands that indent the current line
based on the contents of previous lines.

@deffn Command indent-relative &optional unindented-ok
This command inserts whitespace at point, extending to the same
column as the next @dfn{indent point} of the previous nonblank line.  An
indent point is a non-whitespace character following whitespace.  The
next indent point is the first one at a column greater than the current
column of point.  For example, if point is underneath and to the left of
the first non-blank character of a line of text, it moves to that column
by inserting whitespace.

If the previous nonblank line has no next indent point (i.e., none at a
great enough column position), @code{indent-relative} either does
nothing (if @var{unindented-ok} is non-@code{nil}) or calls
@code{tab-to-tab-stop}.  Thus, if point is underneath and to the right
of the last column of a short line of text, this command ordinarily
moves point to the next tab stop by inserting whitespace.

The return value of @code{indent-relative} is unpredictable.

In the following example, point is at the beginning of the second
line:

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

  In this next example, point is between the @samp{m} and @samp{p} of
@samp{jumped}:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@deffn Command indent-relative-maybe
@comment !!SourceFile indent.el
This command indents the current line like the previous nonblank line,
by calling @code{indent-relative} with @code{t} as the
@var{unindented-ok} argument.  The return value is unpredictable.

If the previous nonblank line has no indent points beyond the current
column, this command does nothing.
@end deffn

@node Indent Tabs
@comment  node-name,  next,  previous,  up
@subsection Adjustable ``Tab Stops''
@cindex tabs stops for indentation

  This section explains the mechanism for user-specified ``tab stops''
and the mechanisms that use and set them.  The name ``tab stops'' is
used because the feature is similar to that of the tab stops on a
typewriter.  The feature works by inserting an appropriate number of
spaces and tab characters to reach the next tab stop column; it does not
affect the display of tab characters in the buffer (@pxref{Usual
Display}).  Note that the @key{TAB} character as input uses this tab
stop feature only in a few major modes, such as Text mode.

@deffn Command tab-to-tab-stop
This command inserts spaces or tabs before point, up to the next tab
stop column defined by @code{tab-stop-list}.  It searches the list for
an element greater than the current column number, and uses that element
as the column to indent to.  It does nothing if no such element is
found.
@end deffn

@defopt tab-stop-list
This variable is the list of tab stop columns used by
@code{tab-to-tab-stops}.  The elements should be integers in increasing
order.  The tab stop columns need not be evenly spaced.

Use @kbd{M-x edit-tab-stops} to edit the location of tab stops
interactively.
@end defopt

@node Motion by Indent
@subsection Indentation-Based Motion Commands

  These commands, primarily for interactive use, act based on the
indentation in the text.

@deffn Command back-to-indentation 
@comment !!SourceFile simple.el
This command moves point to the first non-whitespace character in the
current line (which is the line in which point is located).  It returns
@code{nil}.
@end deffn

@deffn Command backward-to-indentation arg
@comment !!SourceFile simple.el
This command moves point backward @var{arg} lines and then to the
first nonblank character on that line.  It returns @code{nil}.
@end deffn

@deffn Command forward-to-indentation arg
@comment !!SourceFile simple.el
This command moves point forward @var{arg} lines and then to the first
nonblank character on that line.  It returns @code{nil}.
@end deffn

@node Case Changes
@comment  node-name,  next,  previous,  up
@section Case Changes
@cindex case conversion in buffers

  The case change commands described here work on text in the current
buffer.  @xref{Case Conversion}, for case conversion functions that work
on strings and characters.  @xref{Case Tables}, for how to customize
which characters are upper or lower case and how to convert them.

@deffn Command capitalize-region start end
This function capitalizes all words in the region defined by
@var{start} and @var{end}.  To capitalize means to convert each word's
first character to upper case and convert the rest of each word to lower
case.  The function returns @code{nil}.

If one end of the region is in the middle of a word, the part of the
word within the region is treated as an entire word.

When @code{capitalize-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 44)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command downcase-region start end
This function converts all of the letters in the region defined by
@var{start} and @var{end} to lower case.  The function returns
@code{nil}.

When @code{downcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command upcase-region start end
This function converts all of the letters in the region defined by
@var{start} and @var{end} to upper case.  The function returns
@code{nil}.

When @code{upcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command capitalize-word count
This function capitalizes @var{count} words after point, moving point
over as it does.  To capitalize means to convert each word's first
character to upper case and convert the rest of each word to lower case.
If @var{count} is negative, the function capitalizes the
@minus{}@var{count} previous words but does not move point.  The value
is @code{nil}.

If point is in the middle of a word, the part of the word before point
is ignored when moving forward.  The rest is treated as an entire word.

When @code{capitalize-word} is called interactively, @var{count} is
set to the numeric prefix argument.
@end deffn

@deffn Command downcase-word count
This function converts the @var{count} words after point to all lower
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{downcase-word} is called interactively, @var{count} is set
to the numeric prefix argument.
@end deffn

@deffn Command upcase-word count
This function converts the @var{count} words after point to all upper
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{upcase-word} is called interactively, @var{count} is set to
the numeric prefix argument.
@end deffn

@node Text Properties
@section Text Properties
@cindex text properties
@cindex attributes of text
@cindex properties of text

  Each character position in a buffer or a string can have a @dfn{text
property list}, much like the property list of a symbol (@pxref{Property
Lists}).  The properties belong to a particular character at a
particular place, such as, the letter @samp{T} at the beginning of this
sentence or the first @samp{o} in @samp{foo}---if the same character
occurs in two different places, the two occurrences generally have
different properties.

  Each property has a name and a value.  Both of these can be any Lisp
object, but the name is normally a symbol.  The usual way to access the
property list is to specify a name and ask what value corresponds to it.

  If a character has a @code{category} property, we call it the
@dfn{category} of the character.  It should be a symbol.  The properties
of the symbol serve as defaults for the properties of the character.

  Copying text between strings and buffers preserves the properties
along with the characters; this includes such diverse functions as
@code{substring}, @code{insert}, and @code{buffer-substring}.

@menu
* Examining Properties::   Looking at the properties of one character.
* Changing Properties::	   Setting the properties of a range of text.
* Property Search::	   Searching for where a property changes value.
* Special Properties::	   Particular properties with special meanings.
* Format Properties::      Properties for representing formatting of text.
* Sticky Properties::      How inserted text gets properties from
                             neighboring text.
* Saving Properties::      Saving text properties in files, and reading
                             them back.
* Lazy Properties::        Computing text properties in a lazy fashion
                             only when text is examined.
* Clickable Text::         Using text properties to make regions of text
                             do something when you click on them.
* Fields::                 The @code{field} property defines
                             fields within the buffer.
* Not Intervals::	   Why text properties do not use
			     Lisp-visible text intervals.
@end menu

@node Examining Properties
@subsection Examining Text Properties

  The simplest way to examine text properties is to ask for the value of
a particular property of a particular character.  For that, use
@code{get-text-property}.  Use @code{text-properties-at} to get the
entire property list of a character.  @xref{Property Search}, for
functions to examine the properties of a number of characters at once.

  These functions handle both strings and buffers.  Keep in mind that
positions in a string start from 0, whereas positions in a buffer start
from 1.

@defun get-text-property pos prop &optional object
This function returns the value of the @var{prop} property of the
character after position @var{pos} in @var{object} (a buffer or
string).  The argument @var{object} is optional and defaults to the
current buffer.

If there is no @var{prop} property strictly speaking, but the character
has a category that is a symbol, then @code{get-text-property} returns
the @var{prop} property of that symbol.
@end defun

@defun get-char-property pos prop &optional object
This function is like @code{get-text-property}, except that it checks
overlays first and then text properties.  @xref{Overlays}.

The argument @var{object} may be a string, a buffer, or a window.  If it
is a window, then the buffer displayed in that window is used for text
properties and overlays, but only the overlays active for that window
are considered.  If @var{object} is a buffer, then all overlays in that
buffer are considered, as well as text properties.  If @var{object} is a
string, only text properties are considered, since strings never have
overlays.
@end defun

@defvar char-property-alias-alist
This variable holds an alist which maps property names to a list of
alternative property names.  If a character does not specify a direct
value for a property, the alternative property names are consulted in
order; the first non-nil value is used.  This variable takes
precedence over @code{default-text-properties}, and @code{category}
properties take precedence over this variable.
@end defvar

@defun text-properties-at position &optional object
This function returns the entire property list of the character at
@var{position} in the string or buffer @var{object}.  If @var{object} is
@code{nil}, it defaults to the current buffer.
@end defun

@defvar default-text-properties
This variable holds a property list giving default values for text
properties.  Whenever a character does not specify a value for a
property, neither directly, through a category symbol, or through
@code{char-property-alias-alist}, the value stored in this list is
used instead.  Here is an example:

@example
(setq default-text-properties '(foo 69)
      char-property-alias-alist nil)
;; @r{Make sure character 1 has no properties of its own.}
(set-text-properties 1 2 nil)
;; @r{What we get, when we ask, is the default value.}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@subsection Changing Text Properties

  The primitives for changing properties apply to a specified range of
text in a buffer or string.  The function @code{set-text-properties}
(see end of section) sets the entire property list of the text in that
range; more often, it is useful to add, change, or delete just certain
properties specified by name.

  Since text properties are considered part of the contents of the
buffer (or string), and can affect how a buffer looks on the screen, any
change in buffer text properties marks the buffer as modified.  Buffer
text property changes are undoable also (@pxref{Undo}).

@defun put-text-property start end prop value &optional object
This function sets the @var{prop} property to @var{value} for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.
@end defun

@defun add-text-properties start end props &optional object
This function adds or overrides text properties for the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to add.  It should
have the form of a property list (@pxref{Property Lists}): a list whose
elements include the property names followed alternately by the
corresponding values.

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
its values agree with those in the text).

For example, here is how to set the @code{comment} and @code{face}
properties of a range of text:

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
This function deletes specified text properties from the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to delete.  It
should have the form of a property list (@pxref{Property Lists}): a list
whose elements are property names alternating with corresponding values.
But only the names matter---the values that accompany them are ignored.
For example, here's how to remove the @code{face} property.

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
if no character in the specified text had any of those properties).

To remove all text properties from certain text, use
@code{set-text-properties} and specify @code{nil} for the new property
list.
@end defun

@defun set-text-properties start end props &optional object
This function completely replaces the text property list for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} is the new property list.  It should be a list
whose elements are property names alternating with corresponding values.

After @code{set-text-properties} returns, all the characters in the
specified range have identical properties.

If @var{props} is @code{nil}, the effect is to get rid of all properties
from the specified range of text.  Here's an example:

@example
(set-text-properties @var{start} @var{end} nil)
@end example
@end defun

  The easiest way to make a string with text properties
is with @code{propertize}:

@defun propertize string &rest properties
@tindex propertize
This function returns a copy of @var{string} which has the text
properties @var{properties}.  These properties apply to all the
characters in the string that is returned.  Here is an example that
constructs a string with a @code{face} property and a @code{mouse-face}
property:

@smallexample
(propertize "foo" 'face 'italic
            'mouse-face 'bold-italic)
     @result{} #("foo" 0 3 (mouse-face bold-italic face italic))
@end smallexample

To put different properties on various parts of a string, you can
construct each part with @code{propertize} and then combine them with
@code{concat}:

@smallexample
(concat
 (propertize "foo" 'face 'italic
             'mouse-face 'bold-italic)
 " and "
 (propertize "bar" 'face 'italic
             'mouse-face 'bold-italic))
     @result{} #("foo and bar"
                 0 3 (face italic mouse-face bold-italic)
                 3 8 nil
                 8 11 (face italic mouse-face bold-italic))
@end smallexample
@end defun

  See also the function @code{buffer-substring-no-properties}
(@pxref{Buffer Contents}) which copies text from the buffer
but does not copy its properties.

@node Property Search
@subsection Text Property Search Functions

  In typical use of text properties, most of the time several or many
consecutive characters have the same value for a property.  Rather than
writing your programs to examine characters one by one, it is much
faster to process chunks of text that have the same property value.

  Here are functions you can use to do this.  They use @code{eq} for
comparing property values.  In all cases, @var{object} defaults to the
current buffer.

  For high performance, it's very important to use the @var{limit}
argument to these functions, especially the ones that search for a
single property---otherwise, they may spend a long time scanning to the
end of the buffer, if the property you are interested in does not change.

  These functions do not move point; instead, they return a position (or
@code{nil}).  Remember that a position is always between two characters;
the position returned by these functions is between two characters with
different properties.

@defun next-property-change pos &optional object limit
The function scans the text forward from position @var{pos} in the
string or buffer @var{object} till it finds a change in some text
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond @var{pos} whose
properties are not identical to those of the character just after
@var{pos}.

If @var{limit} is non-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point, 
@code{next-property-change} returns @var{limit}.

The value is @code{nil} if the properties remain unchanged all the way
to the end of @var{object} and @var{limit} is @code{nil}.  If the value
is non-@code{nil}, it is a position greater than or equal to @var{pos}.
The value equals @var{pos} only when @var{limit} equals @var{pos}.

Here is an example of how to scan the buffer by chunks of text within
which all properties are constant:

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    @r{Process text from point to @var{next-change}@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun next-single-property-change pos prop &optional object limit
The function scans the text forward from position @var{pos} in the
string or buffer @var{object} till it finds a change in the @var{prop}
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond @var{pos} whose
@var{prop} property differs from that of the character just after
@var{pos}.

If @var{limit} is non-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point, 
@code{next-single-property-change} returns @var{limit}.

The value is @code{nil} if the property remains unchanged all the way to
the end of @var{object} and @var{limit} is @code{nil}.  If the value is
non-@code{nil}, it is a position greater than or equal to @var{pos}; it
equals @var{pos} only if @var{limit} equals @var{pos}.
@end defun

@defun previous-property-change pos &optional object limit
This is like @code{next-property-change}, but scans back from @var{pos}
instead of forward.  If the value is non-@code{nil}, it is a position
less than or equal to @var{pos}; it equals @var{pos} only if @var{limit}
equals @var{pos}.
@end defun

@defun previous-single-property-change pos prop &optional object limit
This is like @code{next-single-property-change}, but scans back from
@var{pos} instead of forward.  If the value is non-@code{nil}, it is a
position less than or equal to @var{pos}; it equals @var{pos} only if
@var{limit} equals @var{pos}.
@end defun

@defun next-char-property-change pos &optional limit
This is like @code{next-property-change} except that it considers
overlay properties as well as text properties, and if no change is
found before the end of the buffer, it returns the maximum buffer
position rather than @code{nil} (in this sense, it resembles the
corresponding overlay function @code{next-overlay-change}, rather than
@code{next-property-change}).  There is no @var{object} operand
because this function operates only on the current buffer.  It returns
the next address at which either kind of property changes.
@end defun

@defun previous-char-property-change pos &optional limit
This is like @code{next-char-property-change}, but scans back from
@var{pos} instead of forward, and returns the minimum buffer
position if no change is found.
@end defun

@defun next-single-char-property-change pos prop &optional object limit
@tindex next-single-char-property-change
This is like @code{next-single-property-change} except that it
considers overlay properties as well as text properties, and if no
change is found before the end of the @var{object}, it returns the
maximum valid position in @var{object} rather than @code{nil}.  Unlike
@code{next-char-property-change}, this function @emph{does} have an
@var{object} operand; if @var{object} is not a buffer, only
text-properties are considered.
@end defun

@defun previous-single-char-property-change pos prop &optional object limit
@tindex previous-single-char-property-change
This is like @code{next-single-char-property-change}, but scans back
from @var{pos} instead of forward, and returns the minimum valid
position in @var{object} if no change is found.
@end defun

@defun text-property-any start end prop value &optional object
This function returns non-@code{nil} if at least one character between
@var{start} and @var{end} has a property @var{prop} whose value is
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@defun text-property-not-all start end prop value &optional object
This function returns non-@code{nil} if at least one character between
@var{start} and @var{end} does not have a property @var{prop} with value
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@node Special Properties
@subsection Properties with Special Meanings

  Here is a table of text property names that have special built-in
meanings.  The following sections list a few additional special property
names that control filling and property inheritance.  All other names
have no standard meaning, and you can use them as you like.

@table @code
@cindex category of text character
@kindex category @r{(text property)}
@item category
If a character has a @code{category} property, we call it the
@dfn{category} of the character.  It should be a symbol.  The properties
of the symbol serve as defaults for the properties of the character.

@item face
@cindex face codes of text
@kindex face @r{(text property)}
You can use the property @code{face} to control the font and color of
text.  @xref{Faces}, for more information.

In the simplest case, the value is a face name.  It can also be a list;
then each element can be any of these possibilities;

@itemize @bullet
@item
A face name (a symbol or string).

@item
Starting in Emacs 21, a property list of face attributes.  This has the
form (@var{keyword} @var{value} @dots{}), where each @var{keyword} is a
face attribute name and @var{value} is a meaningful value for that
attribute.  With this feature, you do not need to create a face each
time you want to specify a particular attribute for certain text.
@xref{Face Attributes}.

@item
A cons cell of the form @code{(foreground-color . @var{color-name})} or
@code{(background-color . @var{color-name})}.  These elements specify
just the foreground color or just the background color.

@code{(foreground-color . @var{color-name})} is equivalent to
@code{(:foreground @var{color-name})}, and likewise for the background.
@end itemize

You can use Font Lock Mode (@pxref{Font Lock Mode}), to dynamically
update @code{face} properties based on the contents of the text.

@item font-lock-face
@kindex font-lock-face @r{(text property)}
The @code{font-lock-face} property is the same in all respects as the
@code{face} property, but its state of activation is controlled by
@code{font-lock-mode}.  This can be advantageous for special buffers
which are not intended to be user-editable, or for static areas of
text which are always fontified in the same way.
@xref{Precalculated Fontification}.

Strictly speaking, @code{font-lock-face} is not a built-in text
property; rather, it is implemented in Font Lock mode using
@code{char-property-alias-alist}.  @xref{Examining Properties}.

This property is new in Emacs 21.4.

@item mouse-face
@kindex mouse-face @r{(text property)}
The property @code{mouse-face} is used instead of @code{face} when the
mouse is on or near the character.  For this purpose, ``near'' means
that all text between the character and where the mouse is have the same
@code{mouse-face} property value.

@item fontified
@kindex fontified @r{(text property)}
This property, if non-@code{nil}, says that text in the buffer has
had faces assigned automatically by a feature such as Font-Lock mode.
@xref{Auto Faces}.

@item display
@kindex display @r{(text property)}
This property activates various features that change the
way text is displayed.  For example, it can make text appear taller
or shorter, higher or lower, wider or narrow, or replaced with an image.
@xref{Display Property}.

@item help-echo
@kindex help-echo @r{(text property)}
@cindex tooltip
@anchor{Text help-echo}
If text has a string as its @code{help-echo} property, then when you
move the mouse onto that text, Emacs displays that string in the echo
area, or in the tooltip window (@pxref{Tooltips,,, emacs, The GNU Emacs
Manual}).

If the value of the @code{help-echo} property is a function, that
function is called with three arguments, @var{window}, @var{object} and
@var{position} and should return a help string or @var{nil} for
none.  The first argument, @var{window} is the window in which
the help was found.  The second, @var{object}, is the buffer, overlay or
string which had the @code{help-echo} property.  The @var{position}
argument is as follows:

@itemize @bullet{}
@item
If @var{object} is a buffer, @var{pos} is the position in the buffer
where the @code{help-echo} text property was found.
@item
If @var{object} is an overlay, that overlay has a @code{help-echo}
property, and @var{pos} is the position in the overlay's buffer under
the mouse.
@item
If @var{object} is a string (an overlay string or a string displayed
with the @code{display} property), @var{pos} is the position in that
string under the mouse.
@end itemize

If the value of the @code{help-echo} property is neither a function nor
a string, it is evaluated to obtain a help string.

You can alter the way help text is displayed by setting the variable
@code{show-help-function} (@pxref{Help display}).

This feature is used in the mode line and for other active text.

@item keymap
@cindex keymap of character
@kindex keymap @r{(text property)}
The @code{keymap} property specifies an additional keymap for
commands.  The property's value for the character after point, if
non-@code{nil}, is used for key lookup before the buffer's local map.
(For mouse clicks, the @code{keymap} property of the character clicked
on is the one used.)  If the property value is a symbol, the symbol's
function definition is used as the keymap.  @xref{Active Keymaps}.

@item local-map
@kindex local-map @r{(text property)}
This property specifies a keymap to use @emph{instead of} the buffer's
local map.  If the property value is a symbol, the symbol's function
definition is used as the keymap.  For most purposes (perhaps all
purposes), the @code{keymap} is superior.

@item syntax-table
The @code{syntax-table} property overrides what the syntax table says
about this particular character.  @xref{Syntax Properties}.

@item read-only
@cindex read-only character
@kindex read-only @r{(text property)}
If a character has the property @code{read-only}, then modifying that
character is not allowed.  Any command that would do so gets an error,
@code{text-read-only}.

Insertion next to a read-only character is an error if inserting
ordinary text there would inherit the @code{read-only} property due to
stickiness.  Thus, you can control permission to insert next to
read-only text by controlling the stickiness.  @xref{Sticky Properties}.

Since changing properties counts as modifying the buffer, it is not
possible to remove a @code{read-only} property unless you know the
special trick: bind @code{inhibit-read-only} to a non-@code{nil} value
and then remove the property.  @xref{Read Only Buffers}.

@item invisible
@kindex invisible @r{(text property)}
A non-@code{nil} @code{invisible} property can make a character invisible
on the screen.  @xref{Invisible Text}, for details.

@item intangible
@kindex intangible @r{(text property)}
If a group of consecutive characters have equal and non-@code{nil}
@code{intangible} properties, then you cannot place point between them.
If you try to move point forward into the group, point actually moves to
the end of the group.  If you try to move point backward into the group,
point actually moves to the start of the group.

When the variable @code{inhibit-point-motion-hooks} is non-@code{nil},
the @code{intangible} property is ignored.

@item field
@kindex field @r{(text property)}
Consecutive characters with the same @code{field} property constitute a
@dfn{field}.  Some motion functions including @code{forward-word} and
@code{beginning-of-line} stop moving at a field boundary.
@xref{Fields}.

@item modification-hooks
@cindex change hooks for a character
@cindex hooks for changing a character
@kindex modification-hooks @r{(text property)}
If a character has the property @code{modification-hooks}, then its
value should be a list of functions; modifying that character calls all
of those functions.  Each function receives two arguments: the beginning
and end of the part of the buffer being modified.  Note that if a
particular modification hook function appears on several characters
being modified by a single primitive, you can't predict how many times
the function will be called.

@item insert-in-front-hooks
@itemx insert-behind-hooks
@kindex insert-in-front-hooks @r{(text property)}
@kindex insert-behind-hooks @r{(text property)}
The operation of inserting text in a buffer also calls the functions
listed in the @code{insert-in-front-hooks} property of the following
character and in the @code{insert-behind-hooks} property of the
preceding character.  These functions receive two arguments, the
beginning and end of the inserted text.  The functions are called
@emph{after} the actual insertion takes place.

See also @ref{Change Hooks}, for other hooks that are called
when you change text in a buffer.

@item point-entered
@itemx point-left
@cindex hooks for motion of point
@kindex point-entered @r{(text property)}
@kindex point-left @r{(text property)}
The special properties @code{point-entered} and @code{point-left}
record hook functions that report motion of point.  Each time point
moves, Emacs compares these two property values:

@itemize @bullet
@item
the @code{point-left} property of the character after the old location,
and
@item
the @code{point-entered} property of the character after the new
location.
@end itemize

@noindent
If these two values differ, each of them is called (if not @code{nil})
with two arguments: the old value of point, and the new one.

The same comparison is made for the characters before the old and new
locations.  The result may be to execute two @code{point-left} functions
(which may be the same function) and/or two @code{point-entered}
functions (which may be the same function).  In any case, all the
@code{point-left} functions are called first, followed by all the
@code{point-entered} functions.

It is possible using @code{char-after} to examine characters at various
positions without moving point to those positions.  Only an actual
change in the value of point runs these hook functions.
@end table

@defvar inhibit-point-motion-hooks
When this variable is non-@code{nil}, @code{point-left} and
@code{point-entered} hooks are not run, and the @code{intangible}
property has no effect.  Do not set this variable globally; bind it with
@code{let}.
@end defvar

@defvar show-help-function
@tindex show-help-function
@anchor{Help display} If this variable is non-@code{nil}, it specifies a
function called to display help strings.  These may be @code{help-echo}
properties, menu help strings (@pxref{Simple Menu Items},
@pxref{Extended Menu Items}), or tool bar help strings (@pxref{Tool
Bar}).  The specified function is called with one argument, the help
string to display.  Tooltip mode (@pxref{Tooltips,,, emacs, The GNU Emacs
Manual}) provides an example.
@end defvar

@node Format Properties
@subsection Formatted Text Properties

  These text properties affect the behavior of the fill commands.  They
are used for representing formatted text.  @xref{Filling}, and
@ref{Margins}.

@table @code
@item hard
If a newline character has this property, it is a ``hard'' newline.
The fill commands do not alter hard newlines and do not move words
across them.  However, this property takes effect only if the variable
@code{use-hard-newlines} is non-@code{nil}.

@item right-margin
This property specifies an extra right margin for filling this part of the
text.

@item left-margin
This property specifies an extra left margin for filling this part of the
text.

@item justification
This property specifies the style of justification for filling this part
of the text.
@end table

@node Sticky Properties
@subsection Stickiness of Text Properties
@cindex sticky text properties
@cindex inheritance of text properties

  Self-inserting characters normally take on the same properties as the
preceding character.  This is called @dfn{inheritance} of properties.

  In a Lisp program, you can do insertion with inheritance or without,
depending on your choice of insertion primitive.  The ordinary text
insertion functions such as @code{insert} do not inherit any properties.
They insert text with precisely the properties of the string being
inserted, and no others.  This is correct for programs that copy text
from one context to another---for example, into or out of the kill ring.
To insert with inheritance, use the special primitives described in this
section.  Self-inserting characters inherit properties because they work
using these primitives.

  When you do insertion with inheritance, @emph{which} properties are
inherited, and from where, depends on which properties are @dfn{sticky}.
Insertion after a character inherits those of its properties that are
@dfn{rear-sticky}.  Insertion before a character inherits those of its
properties that are @dfn{front-sticky}.  When both sides offer different
sticky values for the same property, the previous character's value
takes precedence.

  By default, a text property is rear-sticky but not front-sticky; thus,
the default is to inherit all the properties of the preceding character,
and nothing from the following character.

  You can control the stickiness of various text properties with two
specific text properties, @code{front-sticky} and @code{rear-nonsticky},
and with the variable @code{text-property-default-nonsticky}.  You can
use the variable to specify a different default for a given property.
You can use those two text properties to make any specific properties
sticky or nonsticky in any particular part of the text.

  If a character's @code{front-sticky} property is @code{t}, then all
its properties are front-sticky.  If the @code{front-sticky} property is
a list, then the sticky properties of the character are those whose
names are in the list.  For example, if a character has a
@code{front-sticky} property whose value is @code{(face read-only)},
then insertion before the character can inherit its @code{face} property
and its @code{read-only} property, but no others.

  The @code{rear-nonsticky} property works the opposite way.  Most
properties are rear-sticky by default, so the @code{rear-nonsticky}
property says which properties are @emph{not} rear-sticky.  If a
character's @code{rear-nonsticky} property is @code{t}, then none of its
properties are rear-sticky.  If the @code{rear-nonsticky} property is a
list, properties are rear-sticky @emph{unless} their names are in the
list.

@defvar text-property-default-nonsticky
@tindex text-property-default-nonsticky
This variable holds an alist which defines the default rear-stickiness
of various text properties.  Each element has the form
@code{(@var{property} . @var{nonstickiness})}, and it defines the
stickiness of a particular text property, @var{property}.

If @var{nonstickiness} is non-@code{nil}, this means that the property
@var{property} is rear-nonsticky by default.  Since all properties are
front-nonsticky by default, this makes @var{property} nonsticky in both
directions by default.

The text properties @code{front-sticky} and @code{rear-nonsticky}, when
used, take precedence over the default @var{nonstickiness} specifed in
@code{text-property-default-nonsticky}.
@end defvar

  Here are the functions that insert text with inheritance of properties:

@defun insert-and-inherit &rest strings
Insert the strings @var{strings}, just like the function @code{insert},
but inherit any sticky properties from the adjoining text.
@end defun

@defun insert-before-markers-and-inherit &rest strings
Insert the strings @var{strings}, just like the function
@code{insert-before-markers}, but inherit any sticky properties from the
adjoining text.
@end defun

  @xref{Insertion}, for the ordinary insertion functions which do not
inherit.

@node Saving Properties
@subsection Saving Text Properties in Files
@cindex text properties in files
@cindex saving text properties

  You can save text properties in files (along with the text itself),
and restore the same text properties when visiting or inserting the
files, using these two hooks:

@defvar write-region-annotate-functions
This variable's value is a list of functions for @code{write-region} to
run to encode text properties in some fashion as annotations to the text
being written in the file.  @xref{Writing to Files}.

Each function in the list is called with two arguments: the start and
end of the region to be written.  These functions should not alter the
contents of the buffer.  Instead, they should return lists indicating
annotations to write in the file in addition to the text in the
buffer.

Each function should return a list of elements of the form
@code{(@var{position} . @var{string})}, where @var{position} is an
integer specifying the relative position within the text to be written,
and @var{string} is the annotation to add there.

Each list returned by one of these functions must be already sorted in
increasing order by @var{position}.  If there is more than one function,
@code{write-region} merges the lists destructively into one sorted list.

When @code{write-region} actually writes the text from the buffer to the
file, it intermixes the specified annotations at the corresponding
positions.  All this takes place without modifying the buffer.
@end defvar

@defvar after-insert-file-functions
This variable holds a list of functions for @code{insert-file-contents}
to call after inserting a file's contents.  These functions should scan
the inserted text for annotations, and convert them to the text
properties they stand for.

Each function receives one argument, the length of the inserted text;
point indicates the start of that text.  The function should scan that
text for annotations, delete them, and create the text properties that
the annotations specify.  The function should return the updated length
of the inserted text, as it stands after those changes.  The value
returned by one function becomes the argument to the next function.

These functions should always return with point at the beginning of
the inserted text.

The intended use of @code{after-insert-file-functions} is for converting
some sort of textual annotations into actual text properties.  But other
uses may be possible.
@end defvar

We invite users to write Lisp programs to store and retrieve text
properties in files, using these hooks, and thus to experiment with
various data formats and find good ones.  Eventually we hope users 
will produce good, general extensions we can install in Emacs.

We suggest not trying to handle arbitrary Lisp objects as text property
names or values---because a program that general is probably difficult
to write, and slow.  Instead, choose a set of possible data types that
are reasonably flexible, and not too hard to encode.

@xref{Format Conversion}, for a related feature.

@c ??? In next edition, merge this info Format Conversion.

@node Lazy Properties
@subsection Lazy Computation of Text Properties

  Instead of computing text properties for all the text in the buffer,
you can arrange to compute the text properties for parts of the text
when and if something depends on them.

  The primitive that extracts text from the buffer along with its
properties is @code{buffer-substring}.  Before examining the properties,
this function runs the abnormal hook @code{buffer-access-fontify-functions}.

@defvar buffer-access-fontify-functions
This variable holds a list of functions for computing text properties.
Before @code{buffer-substring} copies the text and text properties for a
portion of the buffer, it calls all the functions in this list.  Each of
the functions receives two arguments that specify the range of the
buffer being accessed.  (The buffer itself is always the current
buffer.)
@end defvar

  The function @code{buffer-substring-no-properties} does not call these
functions, since it ignores text properties anyway.

  In order to prevent the hook functions from being called more than
once for the same part of the buffer, you can use the variable
@code{buffer-access-fontified-property}.

@defvar buffer-access-fontified-property
If this value's variable is non-@code{nil}, it is a symbol which is used
as a text property name.  A non-@code{nil} value for that text property
means, ``the other text properties for this character have already been
computed.''

If all the characters in the range specified for @code{buffer-substring}
have a non-@code{nil} value for this property, @code{buffer-substring}
does not call the @code{buffer-access-fontify-functions} functions.  It
assumes these characters already have the right text properties, and
just copies the properties they already have.

The normal way to use this feature is that the
@code{buffer-access-fontify-functions} functions add this property, as
well as others, to the characters they operate on.  That way, they avoid
being called over and over for the same text.
@end defvar

@node Clickable Text
@subsection Defining Clickable Text
@cindex clickable text

  There are two ways to set up @dfn{clickable text} in a buffer.
There are typically two parts of this: to make the text highlight
when the mouse is over it, and to make a mouse button do something
when you click it on that part of the text.

  Highlighting is done with the @code{mouse-face} text property.
Here is an example of how Dired does it:

@smallexample
(condition-case nil
    (if (dired-move-to-filename)
        (put-text-property (point)
                           (save-excursion
                             (dired-move-to-end-of-filename)
                             (point))
                           'mouse-face 'highlight))
  (error nil))
@end smallexample

@noindent
The first two arguments to @code{put-text-property} specify the
beginning and end of the text.

  The usual way to make the mouse do something when you click it
on this text is to define @code{mouse-2} in the major mode's
keymap.  The job of checking whether the click was on clickable text
is done by the command definition.  Here is how Dired does it:

@smallexample
(defun dired-mouse-find-file-other-window (event)
  "In dired, visit the file or directory name you click on."
  (interactive "e")
  (let (file)
    (save-excursion
      (set-buffer (window-buffer (posn-window (event-end event))))
      (save-excursion
        (goto-char (posn-point (event-end event)))
        (setq file (dired-get-filename))))
    (select-window (posn-window (event-end event)))
    (find-file-other-window (file-name-sans-versions file t))))
@end smallexample

@noindent
The reason for the outer @code{save-excursion} construct is to avoid
changing the current buffer; the reason for the inner one is to avoid
permanently altering point in the buffer you click on.  In this case,
Dired uses the function @code{dired-get-filename} to determine which
file to visit, based on the position found in the event.

  Instead of defining a mouse command for the major mode, you can define
a key binding for the clickable text itself, using the @code{keymap}
text property:

@example
(let ((map (make-sparse-keymap)))
  (define-key map [mouse-2] 'operate-this-button)
  (put-text-property (point)
                     (save-excursion
                       (dired-move-to-end-of-filename)
                       (point))
                     'keymap map))
@end example

@noindent
This method makes it possible to define different commands for various
clickable pieces of text.  Also, the major mode definition (or the
global definition) remains available for the rest of the text in the
buffer.

@node Fields
@subsection Defining and Using Fields
@cindex fields

  A field is a range of consecutive characters in the buffer that are
identified by having the same value (comparing with @code{eq}) of the
@code{field} property (either a text-property or an overlay property).
This section describes special functions that are available for
operating on fields.

  You specify a field with a buffer position, @var{pos}.  We think of
each field as containing a range of buffer positions, so the position
you specify stands for the field containing that position.

  When the characters before and after @var{pos} are part of the same
field, there is no doubt which field contains @var{pos}: the one those
characters both belong to.  When @var{pos} is at a boundary between
fields, which field it belongs to depends on the stickiness of the
@code{field} properties of the two surrounding characters (@pxref{Sticky
Properties}).  The field whose property would be inherited by text
inserted at @var{pos} is the field that contains @var{pos}.

  There is an anomalous case where newly inserted text at @var{pos}
would not inherit the @code{field} property from either side.  This
happens if the previous character's @code{field} property is not
rear-sticky, and the following character's @code{field} property is not
front-sticky.  In this case, @var{pos} belongs to neither the preceding
field nor the following field; the field functions treat it as belonging
to an empty field whose beginning and end are both at @var{pos}.

  In all of these functions, if @var{pos} is omitted or @code{nil}, the
value of point is used by default.

@defun field-beginning &optional pos escape-from-edge limit
@tindex field-beginning
This function returns the beginning of the field specified by @var{pos}.

If @var{pos} is at the beginning of its field, and
@var{escape-from-edge} is non-@code{nil}, then the return value is
always the beginning of the preceding field that @emph{ends} at @var{pos},
regardless of the stickiness of the @code{field} properties around
@var{pos}.

If @var{limit} is non-@code{nil}, it is a buffer position; if the
beginning of the field is before @var{limit}, then @var{limit} will be
returned instead.
@end defun

@defun field-end &optional pos escape-from-edge limit
@tindex field-end
This function returns the end of the field specified by @var{pos}.

If @var{pos} is at the end of its field, and @var{escape-from-edge} is
non-@code{nil}, then the return value is always the end of the following
field that @emph{begins} at @var{pos}, regardless of the stickiness of
the @code{field} properties around @var{pos}.

If @var{limit} is non-@code{nil}, it is a buffer position; if the end
of the field is after @var{limit}, then @var{limit} will be returned
instead.
@end defun

@defun field-string &optional pos
@tindex field-string
This function returns the contents of the field specified by @var{pos},
as a string.
@end defun

@defun field-string-no-properties &optional pos
@tindex field-string-no-properties
This function returns the contents of the field specified by @var{pos},
as a string, discarding text properties.
@end defun

@defun delete-field &optional pos
@tindex delete-field
This function deletes the text of the field specified by @var{pos}.
@end defun

@defun constrain-to-field new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property
@tindex constrain-to-field
This function ``constrains'' @var{new-pos} to the field that
@var{old-pos} belongs to---in other words, it returns the position
closest to @var{new-pos} that is in the same field as @var{old-pos}.

If @var{new-pos} is @code{nil}, then @code{constrain-to-field} uses
the value of point instead, and moves point to the resulting position.

If @var{old-pos} is at the boundary of two fields, then the acceptable
positions for @var{new-pos} depend on the value of the optional argument
@var{escape-from-edge}.  If @var{escape-from-edge} is @code{nil}, then
@var{new-pos} is constrained to the field that has the same @code{field}
property (either a text-property or an overlay property) that new
characters inserted at @var{old-pos} would get.  (This depends on the
stickiness of the @code{field} property for the characters before and
after @var{old-pos}.)  If @var{escape-from-edge} is non-@code{nil},
@var{new-pos} is constrained to the union of the two adjacent fields.
Additionally, if two fields are separated by another field with the
special value @code{boundary}, then any point within this special field
is also considered to be ``on the boundary.''

If the optional argument @var{only-in-line} is non-@code{nil}, and
constraining @var{new-pos} in the usual way would move it to a different
line, @var{new-pos} is returned unconstrained.  This used in commands
that move by line, such as @code{next-line} and
@code{beginning-of-line}, so that they respect field boundaries only in
the case where they can still move to the right line.

If the optional argument @var{inhibit-capture-property} is
non-@code{nil}, and @var{old-pos} has a non-@code{nil} property of that
name, then any field boundaries are ignored.

You can cause @code{constrain-to-field} to ignore all field boundaries
(and so never constrain anything) by binding the variable
@code{inhibit-field-text-motion} to a non-nil value.
@end defun

@node Not Intervals
@subsection Why Text Properties are not Intervals
@cindex intervals

  Some editors that support adding attributes to text in the buffer do
so by letting the user specify ``intervals'' within the text, and adding
the properties to the intervals.  Those editors permit the user or the
programmer to determine where individual intervals start and end.  We
deliberately provided a different sort of interface in Emacs Lisp to
avoid certain paradoxical behavior associated with text modification.

  If the actual subdivision into intervals is meaningful, that means you
can distinguish between a buffer that is just one interval with a
certain property, and a buffer containing the same text subdivided into
two intervals, both of which have that property.

  Suppose you take the buffer with just one interval and kill part of
the text.  The text remaining in the buffer is one interval, and the
copy in the kill ring (and the undo list) becomes a separate interval.
Then if you yank back the killed text, you get two intervals with the
same properties.  Thus, editing does not preserve the distinction
between one interval and two.

  Suppose we ``fix'' this problem by coalescing the two intervals when
the text is inserted.  That works fine if the buffer originally was a
single interval.  But suppose instead that we have two adjacent
intervals with the same properties, and we kill the text of one interval
and yank it back.  The same interval-coalescence feature that rescues
the other case causes trouble in this one: after yanking, we have just
one interval.  One again, editing does not preserve the distinction
between one interval and two.

  Insertion of text at the border between intervals also raises
questions that have no satisfactory answer.

  However, it is easy to arrange for editing to behave consistently for
questions of the form, ``What are the properties of this character?''
So we have decided these are the only questions that make sense; we have
not implemented asking questions about where intervals start or end.

  In practice, you can usually use the text property search functions in
place of explicit interval boundaries.  You can think of them as finding
the boundaries of intervals, assuming that intervals are always
coalesced whenever possible.  @xref{Property Search}.

  Emacs also provides explicit intervals as a presentation feature; see
@ref{Overlays}.

@node Substitution
@section Substituting for a Character Code

  The following functions replace characters within a specified region
based on their character codes.

@defun subst-char-in-region start end old-char new-char &optional noundo
@cindex replace characters
This function replaces all occurrences of the character @var{old-char}
with the character @var{new-char} in the region of the current buffer
defined by @var{start} and @var{end}.

@cindex undo avoidance
If @var{noundo} is non-@code{nil}, then @code{subst-char-in-region} does
not record the change for undo and does not mark the buffer as modified.
This was useful for controlling the old selective display feature
(@pxref{Selective Display}).

@code{subst-char-in-region} does not move point and returns
@code{nil}.

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@defun translate-region start end table
This function applies a translation table to the characters in the
buffer between positions @var{start} and @var{end}.

The translation table @var{table} is a string; @code{(aref @var{table}
@var{ochar})} gives the translated character corresponding to
@var{ochar}.  If the length of @var{table} is less than 256, any
characters with codes larger than the length of @var{table} are not
altered by the translation.

The return value of @code{translate-region} is the number of
characters that were actually changed by the translation.  This does
not count characters that were mapped into themselves in the
translation table.
@end defun

@node Registers
@section Registers
@cindex registers

  A register is a sort of variable used in Emacs editing that can hold a
variety of different kinds of values.  Each register is named by a
single character.  All @sc{ascii} characters and their meta variants
(but with the exception of @kbd{C-g}) can be used to name registers.
Thus, there are 255 possible registers.  A register is designated in
Emacs Lisp by the character that is its name.

@defvar register-alist
This variable is an alist of elements of the form @code{(@var{name} .
@var{contents})}.  Normally, there is one element for each Emacs
register that has been used.

The object @var{name} is a character (an integer) identifying the
register.
@end defvar

  The @var{contents} of a register can have several possible types:

@table @asis
@item a number
A number stands for itself.  If @code{insert-register} finds a number
in the register, it converts the number to decimal.

@item a marker
A marker represents a buffer position to jump to.

@item a string
A string is text saved in the register.

@item a rectangle
A rectangle is represented by a list of strings.

@item @code{(@var{window-configuration} @var{position})}
This represents a window configuration to restore in one frame, and a
position to jump to in the current buffer.

@item @code{(@var{frame-configuration} @var{position})}
This represents a frame configuration to restore, and a position
to jump to in the current buffer.

@item (file @var{filename})
This represents a file to visit; jumping to this value visits file
@var{filename}.

@item (file-query @var{filename} @var{position})
This represents a file to visit and a position in it; jumping to this
value visits file @var{filename} and goes to buffer position
@var{position}.  Restoring this type of position asks the user for
confirmation first.
@end table

  The functions in this section return unpredictable values unless
otherwise stated.

@defun get-register reg
This function returns the contents of the register
@var{reg}, or @code{nil} if it has no contents.
@end defun

@defun set-register reg value
This function sets the contents of register @var{reg} to @var{value}.
A register can be set to any value, but the other register functions
expect only certain data types.  The return value is @var{value}.
@end defun

@deffn Command view-register reg
This command displays what is contained in register @var{reg}.
@end deffn

@ignore
@deffn Command point-to-register reg
This command stores both the current location of point and the current
buffer in register @var{reg} as a marker.
@end deffn

@deffn Command jump-to-register reg
@deffnx Command register-to-point reg
@comment !!SourceFile register.el
This command restores the status recorded in register @var{reg}.

If @var{reg} contains a marker, it moves point to the position stored in
the marker.  Since both the buffer and the location within the buffer
are stored by the @code{point-to-register} function, this command can
switch you to another buffer.

If @var{reg} contains a window configuration or a frame configuration.
@code{jump-to-register} restores that configuration.
@end deffn
@end ignore

@deffn Command insert-register reg &optional beforep
This command inserts contents of register @var{reg} into the current
buffer.

Normally, this command puts point before the inserted text, and the
mark after it.  However, if the optional second argument @var{beforep}
is non-@code{nil}, it puts the mark before and point after.
You can pass a non-@code{nil} second argument @var{beforep} to this
function interactively by supplying any prefix argument.

If the register contains a rectangle, then the rectangle is inserted
with its upper left corner at point.  This means that text is inserted
in the current line and underneath it on successive lines.

If the register contains something other than saved text (a string) or
a rectangle (a list), currently useless things happen.  This may be
changed in the future.
@end deffn

@ignore
@deffn Command copy-to-register reg start end &optional delete-flag
This command copies the region from @var{start} to @var{end} into
register @var{reg}.  If @var{delete-flag} is non-@code{nil}, it deletes
the region from the buffer after copying it into the register.
@end deffn

@deffn Command prepend-to-register reg start end &optional delete-flag
This command prepends the region from @var{start} to @var{end} into
register @var{reg}.  If @var{delete-flag} is non-@code{nil}, it deletes
the region from the buffer after copying it to the register.
@end deffn

@deffn Command append-to-register reg start end &optional delete-flag
This command appends the region from @var{start} to @var{end} to the
text already in register @var{reg}.  If @var{delete-flag} is
non-@code{nil}, it deletes the region from the buffer after copying it
to the register.
@end deffn

@deffn Command copy-rectangle-to-register reg start end &optional delete-flag
This command copies a rectangular region from @var{start} to @var{end}
into register @var{reg}.  If @var{delete-flag} is non-@code{nil}, it
deletes the region from the buffer after copying it to the register.
@end deffn

@deffn Command window-configuration-to-register reg
This function stores the window configuration of the selected frame in
register @var{reg}.
@end deffn

@deffn Command frame-configuration-to-register reg
This function stores the current frame configuration in register
@var{reg}.
@end deffn
@end ignore

@node Transposition
@section Transposition of Text

  This subroutine is used by the transposition commands.

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
This function exchanges two nonoverlapping portions of the buffer.
Arguments @var{start1} and @var{end1} specify the bounds of one portion
and arguments @var{start2} and @var{end2} specify the bounds of the
other portion.

Normally, @code{transpose-regions} relocates markers with the transposed
text; a marker previously positioned within one of the two transposed
portions moves along with that portion, thus remaining between the same
two characters in their new position.  However, if @var{leave-markers}
is non-@code{nil}, @code{transpose-regions} does not do this---it leaves
all markers unrelocated.
@end defun

@node Base 64
@section Base 64 Encoding
@cindex base 64 encoding

  Base 64 code is used in email to encode a sequence of 8-bit bytes as
a longer sequence of @sc{ascii} graphic characters.  It is defined in
Internet RFC@footnote{
An RFC, an acronym for @dfn{Request for Comments}, is a numbered
Internet informational document describing a standard.  RFCs are
usually written by technical experts acting on their own initiative,
and are traditionally written in a pragmatic, experience-driven
manner.
}2045.  This section describes the functions for
converting to and from this code.

@defun base64-encode-region beg end &optional no-line-break
@tindex base64-encode-region
This function converts the region from @var{beg} to @var{end} into base
64 code.  It returns the length of the encoded text.  An error is
signaled if a character in the region is multibyte, i.e.@: in a
multibyte buffer the region must contain only characters from the
charsets @code{ascii}, @code{eight-bit-control} and
@code{eight-bit-graphic}.

Normally, this function inserts newline characters into the encoded
text, to avoid overlong lines.  However, if the optional argument
@var{no-line-break} is non-@code{nil}, these newlines are not added, so
the output is just one long line.
@end defun

@defun base64-encode-string string &optional no-line-break
@tindex base64-encode-string
This function converts the string @var{string} into base 64 code.  It
returns a string containing the encoded text.  As for
@code{base64-encode-region}, an error is signaled if a character in the
string is multibyte.

Normally, this function inserts newline characters into the encoded
text, to avoid overlong lines.  However, if the optional argument
@var{no-line-break} is non-@code{nil}, these newlines are not added, so
the result string is just one long line.
@end defun

@defun base64-decode-region beg end
@tindex base64-decode-region
This function converts the region from @var{beg} to @var{end} from base
64 code into the corresponding decoded text.  It returns the length of
the decoded text.

The decoding functions ignore newline characters in the encoded text.
@end defun

@defun base64-decode-string string
@tindex base64-decode-string
This function converts the string @var{string} from base 64 code into
the corresponding decoded text.  It returns a string containing the
decoded text.

The decoding functions ignore newline characters in the encoded text.
@end defun

@node MD5 Checksum
@section MD5 Checksum
@cindex MD5 checksum
@cindex message digest computation

  MD5 cryptographic checksums, or @dfn{message digests}, are 128-bit
``fingerprints'' of a document or program.  They are used to verify
that you have an exact and unaltered copy of the data.  The algorithm
to calculate the MD5 message digest is defined in Internet
RFC@footnote{
For an explanation of what is an RFC, see the footnote in @ref{Base
64}.
}1321.  This section describes the Emacs facilities for computing
message digests.

@defun md5 object &optional start end coding-system noerror
This function returns the MD5 message digest of @var{object}, which
should be a buffer or a string.

The two optional arguments @var{start} and @var{end} are character
positions specifying the portion of @var{object} to compute the
message digest for.  If they are @code{nil} or omitted, the digest is
computed for the whole of @var{object}.

The function @code{md5} does not compute the message digest directly
from the internal Emacs representation of the text (@pxref{Text
Representations}).  Instead, it encodes the text using a coding
system, and computes the message digest from the encoded text.  The
optional fourth argument @var{coding-system} specifies which coding
system to use for encoding the text.  It should be the same coding
system that you used to read the text, or that you used or will use
when saving or sending the text.  @xref{Coding Systems}, for more
information about coding systems.

If @var{coding-system} is @code{nil} or omitted, the default depends
on @var{object}.  If @var{object} is a buffer, the default for
@var{coding-system} is whatever coding system would be chosen by
default for writing this text into a file.  If @var{object} is a
string, the user's most preferred coding system (@pxref{Recognize
Coding, prefer-coding-system, the description of
@code{prefer-coding-system}, emacs, GNU Emacs Manual}) is used.

Normally, @code{md5} signals an error if the text can't be encoded
using the specified or chosen coding system.  However, if
@var{noerror} is non-@code{nil}, it silently uses @code{raw-text}
coding instead.
@end defun

@node Change Hooks
@section Change Hooks
@cindex change hooks
@cindex hooks for text changes

  These hook variables let you arrange to take notice of all changes in
all buffers (or in a particular buffer, if you make them buffer-local).
See also @ref{Special Properties}, for how to detect changes to specific
parts of the text.

  The functions you use in these hooks should save and restore the match
data if they do anything that uses regular expressions; otherwise, they
will interfere in bizarre ways with the editing operations that call
them.

@defvar before-change-functions
This variable holds a list of functions to call before any buffer
modification.  Each function gets two arguments, the beginning and end
of the region that is about to change, represented as integers.  The
buffer that is about to change is always the current buffer.
@end defvar

@defvar after-change-functions
This variable holds a list of functions to call after any buffer
modification.  Each function receives three arguments: the beginning and
end of the region just changed, and the length of the text that existed
before the change.  All three arguments are integers.  The buffer that's
about to change is always the current buffer.

The length of the old text is the difference between the buffer positions
before and after that text as it was before the change.  As for the
changed text, its length is simply the difference between the first two
arguments.
@end defvar

@defmac combine-after-change-calls body...
The macro executes @var{body} normally, but arranges to call the
after-change functions just once for a series of several changes---if
that seems safe.

If a program makes several text changes in the same area of the buffer,
using the macro @code{combine-after-change-calls} around that part of
the program can make it run considerably faster when after-change hooks
are in use.  When the after-change hooks are ultimately called, the
arguments specify a portion of the buffer including all of the changes
made within the @code{combine-after-change-calls} body.

@strong{Warning:} You must not alter the values of
@code{after-change-functions} within
the body of a @code{combine-after-change-calls} form.

@strong{Note:} If the changes you combine occur in widely scattered
parts of the buffer, this will still work, but it is not advisable,
because it may lead to inefficient behavior for some change hook
functions.
@end defmac

The two variables above are temporarily bound to @code{nil} during the
time that any of these functions is running.  This means that if one of
these functions changes the buffer, that change won't run these
functions.  If you do want a hook function to make changes that run
these functions, make it bind these variables back to their usual
values.

One inconvenient result of this protective feature is that you cannot
have a function in @code{after-change-functions} or
@code{before-change-functions} which changes the value of that variable.
But that's not a real limitation.  If you want those functions to change
the list of functions to run, simply add one fixed function to the hook,
and code that function to look in another variable for other functions
to call.  Here is an example:

@example
(setq my-own-after-change-functions nil)
(defun indirect-after-change-function (beg end len)
  (let ((list my-own-after-change-functions))
    (while list
      (funcall (car list) beg end len)
      (setq list (cdr list)))))

@group
(add-hooks 'after-change-functions
           'indirect-after-change-function)
@end group
@end example

@defvar first-change-hook
This variable is a normal hook that is run whenever a buffer is changed
that was previously in the unmodified state.
@end defvar

@defvar inhibit-modification-hooks
@tindex inhibit-modification-hooks
If this variable is non-@code{nil}, all of the change hooks are
disabled; none of them run.  This affects all the hook variables
described above in this section, as well as the hooks attached to
certain special text properties (@pxref{Special Properties}) and overlay
properties (@pxref{Overlay Properties}).

This variable is available starting in Emacs 21.
@end defvar
