;;; fast-lock.el --- Automagic text properties caching for fast Font Lock mode.

;; Copyright (C) 1994, 1995 Free Software Foundation, Inc.

;; Author: Simon Marshall <simon@gnu.ai.mit.edu>
;; Keywords: faces files
;; Version: 3.06

;;; This file is part of GNU Emacs.

;; GNU Emacs is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

;;; Commentary:

;; Purpose:
;;
;; To make visiting a file in `font-lock-mode' faster by restoring its face
;; text properties from automatically saved associated Font Lock cache files.
;;
;; See caveats and feedback below.
;; See also the lazy-lock package.  (But don't use the two at the same time!)

;; Installation:
;; 
;; Put in your ~/.emacs:
;;
;; (add-hook 'font-lock-mode-hook 'turn-on-fast-lock)
;;
;; Start up a new Emacs and use font-lock as usual (except that you can use the
;; so-called "gaudier" fontification regexps on big files without frustration).
;;
;; When you visit a file (which has `font-lock-mode' enabled) that has a
;; corresponding Font Lock cache file associated with it, the Font Lock cache
;; will be loaded from that file instead of being generated by Font Lock code.

;; Caveats:
;;
;; A cache will be saved when visiting a compressed file using crypt++, but not
;; be read.  This is a "feature"/"consequence"/"bug" of crypt++.
;;
;; Version control packages are likely to stamp all over file modification
;; times.  Therefore the act of checking out may invalidate a cache.

;; Feedback:
;;
;; Feedback is welcome.
;; To submit a bug report (or make comments) please use the mechanism provided:
;;
;; M-x fast-lock-submit-bug-report RET

(require 'font-lock)

(eval-when-compile
  ;; Shut Emacs' byte-compiler up (cf. stop me getting mail from users).
  (setq byte-compile-warnings '(free-vars callargs redefine)))

(defun fast-lock-submit-bug-report ()
  "Submit via mail a bug report on fast-lock.el."
  (interactive)
  (let ((reporter-prompt-for-summary-p t))
    (reporter-submit-bug-report "simon@gnu.ai.mit.edu" "fast-lock 3.06"
     '(fast-lock-cache-directories fast-lock-minimum-size
       fast-lock-save-others fast-lock-save-events fast-lock-save-faces)
     nil nil
     (concat "Hi Si.,

I want to report a bug.  I've read the `Bugs' section of `Info' on Emacs, so I
know how to make a clear and unambiguous report.  To reproduce the bug:

Start a fresh Emacs via `" invocation-name " -no-init-file -no-site-file'.
In the `*scratch*' buffer, evaluate:"))))

;;;###autoload
(defvar fast-lock-mode nil)		; for modeline
(defvar fast-lock-cache-timestamp nil)	; for saving/reading
(defvar fast-lock-cache-filename nil)	; for deleting

;; User Variables:

(defvar fast-lock-cache-directories '("." "~/.emacs-flc")
; - `internal', keep each file's Font Lock cache file in the same file.
; - `external', keep each file's Font Lock cache file in the same directory.
  "Directories in which Font Lock cache files are saved and read.
Each item should be either DIR or a cons pair of the form (REGEXP . DIR) where
DIR is a directory name (relative or absolute) and REGEXP is a regexp.

An attempt will be made to save or read Font Lock cache files using these items
until one succeeds (i.e., until a readable or writable one is found).  If an
item contains REGEXP, DIR is used only if the buffer file name matches REGEXP.
For example:

 (list (cons (concat \"^\" (regexp-quote (expand-file-name \"~\"))) \".\")
       \"~/.emacs-flc\")

would cause a file's current directory to be used if the file is under your
home directory hierarchy, or otherwise the absolute directory `~/.emacs-flc'.")

(defvar fast-lock-minimum-size (* 25 1024)
  "If non-nil, the minimum size for buffers.
Only buffers more than this can have associated Font Lock cache files saved.
If nil, means size is irrelevant.")

(defvar fast-lock-save-events '(kill-buffer kill-emacs)
  "A list of events under which caches will be saved.
Valid events are `save-buffer', `kill-buffer' and `kill-emacs'.
If concurrent editing sessions use the same associated cache file for a file's
buffer, then you should add `save-buffer' to this list.")

(defvar fast-lock-save-others t
  "If non-nil, save Font Lock cache files irrespective of file owner.
If nil, means only buffer files known to be owned by you can have associated
Font Lock cache files saved.  Ownership may be unknown for networked files.")

(defvar fast-lock-save-faces
  ;; Since XEmacs uses extents for everything, we have to pick the right ones.
  ;; In XEmacs 19.12 we can't identify which text properties are font-lock's.
  (if (save-match-data (string-match "XEmacs" (emacs-version)))
      '(font-lock-string-face font-lock-doc-string-face font-lock-type-face
	font-lock-function-name-face font-lock-comment-face
	font-lock-keyword-face)
    ;; For Emacs 19.29 I don't think this is generally necessary.
    ;(mapcar 'eval (mapcar 'car font-lock-face-attributes))
    )
  "A list of faces that will be saved in a Font Lock cache file.
If nil, means information for all faces will be saved.")

;; User Functions:

;;;###autoload
(defun fast-lock-mode (&optional arg)
  "Toggle Fast Lock mode.
With arg, turn Fast Lock mode on if and only if arg is positive and the buffer
is associated with a file.  Enable it automatically in your `~/.emacs' by:

 (add-hook 'font-lock-mode-hook 'turn-on-fast-lock)

If Fast Lock mode is enabled, and the current buffer does not contain any text
properties, any associated Font Lock cache is used if its timestamp matches the
buffer's file, and its `font-lock-keywords' match those that you are using.

Font Lock caches may be saved:
 - When you save the file's buffer.
 - When you kill an unmodified file's buffer.
 - When you exit Emacs, for all unmodified or saved buffers.
Depending on the value of `fast-lock-save-events'.
See also the commands `fast-lock-read-cache' and `fast-lock-save-cache'.

Use \\[font-lock-fontify-buffer] to fontify the buffer if the cache is bad.

Various methods of control are provided for the Font Lock cache.  In general,
see variable `fast-lock-cache-directories' and function `fast-lock-cache-name'.
For saving, see variables `fast-lock-minimum-size', `fast-lock-save-events',
`fast-lock-save-others' and `fast-lock-save-faces'.

Use \\[fast-lock-submit-bug-report] to send bug reports or feedback."
  (interactive "P")
  (set (make-local-variable 'fast-lock-mode)
       (and (buffer-file-name)
	    (if arg (> (prefix-numeric-value arg) 0) (not fast-lock-mode))))
  (if (and fast-lock-mode (not font-lock-mode))
      ;; Turned on `fast-lock-mode' rather than using `font-lock-mode-hook'.
      (progn
	(add-hook 'font-lock-mode-hook 'turn-on-fast-lock)
	(font-lock-mode 1))
    ;; Let's get down to business.
    (set (make-local-variable 'fast-lock-cache-timestamp) nil)
    (set (make-local-variable 'fast-lock-cache-filename) nil)
    (if (and fast-lock-mode (not font-lock-fontified))
	(fast-lock-read-cache))))

(defun fast-lock-read-cache ()
  "Read the Font Lock cache for the current buffer.

The following criteria must be met for a Font Lock cache file to be read:
 - Fast Lock mode must be turned on in the buffer.
 - The buffer must not be modified.
 - The buffer's `font-lock-keywords' must match the cache's.
 - The buffer file's timestamp must match the cache's.
 - Criteria imposed by `fast-lock-cache-directories'.

See `fast-lock-mode'."
  (interactive)
  (let ((directories fast-lock-cache-directories)
	(modified (buffer-modified-p)) (inhibit-read-only t)
	(fontified font-lock-fontified))
    (setq fast-lock-cache-filename nil)
    (set (make-local-variable 'font-lock-fontified) nil)
    ;; Keep trying directories until fontification is turned off.
    (while (and directories (not font-lock-fontified))
      (let* ((directory (fast-lock-cache-directory (car directories) nil))
	     (file (and directory (fast-lock-cache-name directory))))
	(condition-case nil
	    (and file (file-readable-p file) (load file t t t))
	  (error nil) (quit nil))
	(setq directories (cdr directories))))
    (set-buffer-modified-p modified)
    (or font-lock-fontified (setq font-lock-fontified fontified))))

(defun fast-lock-save-cache (&optional buffer)
  "Save the Font Lock cache of BUFFER or the current buffer.

The following criteria must be met for a Font Lock cache file to be saved:
 - Fast Lock mode must be turned on in the buffer.
 - The event must be one of `fast-lock-save-events'.
 - The buffer must be at least `fast-lock-minimum-size' bytes long.
 - The buffer file must be owned by you, or `fast-lock-save-others' must be t.
 - The buffer must contain at least one `face' text property.
 - The buffer must not be modified.
 - The buffer file's timestamp must be the same as the file's on disk.
 - The on disk file's timestamp must be different than the buffer's cache.
 - Criteria imposed by `fast-lock-cache-directories'.

See `fast-lock-mode'."
  (interactive)
  (save-excursion
    (and buffer (set-buffer buffer))
    (let ((file-timestamp (visited-file-modtime)) (saved nil))
      (if (and fast-lock-mode
	       ;;
	       ;; "Only save if the buffer matches the file, the file has
	       ;; changed, and it was changed by the current emacs session."
	       ;;
	       ;; Only save if the buffer is not modified,
	       ;; (i.e., so we don't save for something not on disk)
	       (not (buffer-modified-p))
	       ;; and the file's timestamp is the same as the buffer's,
	       ;; (i.e., someone else hasn't written the file in the meantime)
	       (verify-visited-file-modtime (current-buffer))
	       ;; and the file's timestamp is different from the cache's.
	       ;; (i.e., a save has occurred since the cache was read)
	       (not (equal fast-lock-cache-timestamp file-timestamp))
	       ;;
	       ;; Only save if user's restrictions are satisfied.
	       (or (not fast-lock-minimum-size)
		   (<= fast-lock-minimum-size (buffer-size)))
	       (or fast-lock-save-others
		   (eq (user-uid) (nth 2 (file-attributes buffer-file-name))))
	       ;;
	       ;; Only save if there are `face' properties to save.
	       (text-property-not-all (point-min) (point-max) 'face nil))
	  ;; Try each directory until we manage to save or the user quits.
	  (let ((directories fast-lock-cache-directories))
	    (while (and directories (memq saved '(nil error)))
	      (let* ((dir (fast-lock-cache-directory (car directories) t))
		     (file (and dir (fast-lock-cache-name dir))))
		(if (and file (file-writable-p file))
		    (setq saved (fast-lock-save-cache-1 file file-timestamp)))
		(setq directories (cdr directories)))))))))

;;;###autoload
(defun turn-on-fast-lock ()
  "Unconditionally turn on Fast Lock mode."
  (fast-lock-mode 1))

;;; API Functions:

(defun fast-lock-after-fontify-buffer ()
  ;; Delete the Font Lock cache file used to restore fontification, if any.
  (if fast-lock-cache-filename
      (if (file-writable-p fast-lock-cache-filename)
	  (delete-file fast-lock-cache-filename)
	(message "File %s font lock cache cannot be deleted" (buffer-name))))
  ;; Flag so that a cache will be saved later even if the file is never saved.
  (setq fast-lock-cache-timestamp nil))

;; Miscellaneous Functions:

(defun fast-lock-after-save-hook ()
  ;; Do `fast-lock-save-cache' if `save-buffer' is on `fast-lock-save-events'.
  (if (memq 'save-buffer fast-lock-save-events)
      (fast-lock-save-cache)))

(defun fast-lock-kill-buffer-hook ()
  ;; Do `fast-lock-save-cache' if `kill-buffer' is on `fast-lock-save-events'.
  (if (memq 'kill-buffer fast-lock-save-events)
      (fast-lock-save-cache)))

(defun fast-lock-kill-emacs-hook ()
  ;; Do `fast-lock-save-cache's if `kill-emacs' is on `fast-lock-save-events'.
  (if (memq 'kill-emacs fast-lock-save-events)
      (mapcar 'fast-lock-save-cache (buffer-list))))

(defun fast-lock-cache-directory (directory create)
  "Return usable directory based on DIRECTORY.
Returns nil if the directory does not exist, or, if CREATE non-nil, cannot be
created.  DIRECTORY may be a string or a cons pair of the form (REGEXP . DIR).
See `fast-lock-cache-directories'."
  (let ((dir
	 (cond ((not buffer-file-name)
		;; Should never be nil, but `crypt++' screws it up.
		nil)
	       ((stringp directory)
		;; Just a directory.
		directory)
	       (t
		;; A directory iff the file name matches the regexp.
		(let ((bufile (expand-file-name buffer-file-truename))
		      (case-fold-search nil))
		  (if (save-match-data (string-match (car directory) bufile))
		      (cdr directory)))))))
    (cond ((not dir)
	   nil)
	  ((file-accessible-directory-p dir)
	   dir)
	  (create
	   (condition-case nil
	       (progn (make-directory dir t) dir)
	     (error nil))))))

(defun fast-lock-cache-name (directory)
  "Return full cache path name using caching DIRECTORY.
If DIRECTORY is `.', the path is the buffer file name appended with `.flc'.
Otherwise, the path name is constructed from DIRECTORY and the buffer's true
abbreviated file name, with all `/' characters in the name replaced with `#'
characters, and appended with `.flc'.

See `fast-lock-mode'."
  (if (string-equal directory ".")
      (concat buffer-file-name ".flc")
    (let* ((bufile (expand-file-name buffer-file-truename))
	   (chars-alist
	    (if (eq system-type 'emx)
		'((?/ . (?#)) (?# . (?# ?#)) (?: . (?\;)) (?\; . (?\; ?\;)))
	      '((?/ . (?#)) (?# . (?# ?#)))))
	   (mapchars
	    (function (lambda (c) (or (cdr (assq c chars-alist)) (list c))))))
      (concat
       (file-name-as-directory (expand-file-name directory))
       (mapconcat 'char-to-string (apply 'append (mapcar mapchars bufile)) "")
       ".flc"))))

;; Font Lock Cache Processing Functions:

(defun fast-lock-save-cache-1 (file timestamp)
  ;; Save the FILE with the TIMESTAMP as:
  ;; (fast-lock-cache-data Version=2 TIMESTAMP font-lock-keywords PROPERTIES).
  ;; Returns non-nil if a save was attempted to a writable cache file.
  (let ((tpbuf (generate-new-buffer " *fast-lock*"))
	(buname (buffer-name)) (saved t))
    (message "Saving %s font lock cache..." buname)
    (condition-case nil
	(save-excursion
	  (print (list 'fast-lock-cache-data 2
		       (list 'quote timestamp)
		       (list 'quote font-lock-keywords)
		       (list 'quote (fast-lock-get-face-properties)))
		 tpbuf)
	  (set-buffer tpbuf)
	  (write-region (point-min) (point-max) file nil 'quietly)
	  (setq fast-lock-cache-timestamp timestamp
		fast-lock-cache-filename file))
      (error (setq saved 'error)) (quit (setq saved 'quit)))
    (kill-buffer tpbuf)
    (message "Saving %s font lock cache... %s." buname
	     (cond ((eq saved 'error) "failed")
		   ((eq saved 'quit) "aborted")
		   (t "done")))
    ;; We return non-nil regardless of whether a failure occurred.
    saved))

(defun fast-lock-cache-data (version timestamp keywords properties
			     &rest ignored)
  ;; Change from (HIGH LOW) for back compatibility.  Remove for version 3!
  (if (consp (cdr-safe timestamp)) (setcdr timestamp (nth 1 timestamp)))
  ;; Compile KEYWORDS and `font-lock-keywords' in case one is and one isn't.
  (let ((current font-lock-keywords))
    (setq keywords (font-lock-compile-keywords keywords)
	  font-lock-keywords (font-lock-compile-keywords current)))
  ;; Use the Font Lock cache PROPERTIES if we're using cache VERSION format 2,
  ;; the current buffer's file timestamp matches the TIMESTAMP, and the current
  ;; buffer's font-lock-keywords are the same as KEYWORDS.
  (let ((buf-timestamp (visited-file-modtime))
	(buname (buffer-name)) (loaded t))
    (if (or (/= version 2)
	    (buffer-modified-p)
	    (not (equal timestamp buf-timestamp))
	    (not (equal keywords font-lock-keywords)))
	(setq loaded nil)
      (message "Loading %s font lock cache..." buname)
      (condition-case nil
	  (fast-lock-set-face-properties properties)
	(error (setq loaded 'error)) (quit (setq loaded 'quit)))
      (message "Loading %s font lock cache... %s." buname
	       (cond ((eq loaded 'error) "failed")
		     ((eq loaded 'quit) "aborted")
		     (t "done"))))
    ;; If we used the text properties, stop fontification and keep timestamp.
    ;; Kludge warning: `file' comes from sole caller `fast-lock-read-cache'.
    (setq font-lock-fontified (eq loaded t)
	  fast-lock-cache-timestamp (and (eq loaded t) timestamp)
	  fast-lock-cache-filename (and (eq loaded t) file))))

;; Text Properties Processing Functions:

;; This is faster, but fails if adjacent characters have different `face' text
;; properties.  Maybe that's why I dropped it in the first place?
;(defun fast-lock-get-face-properties ()
;  "Return a list of all `face' text properties in the current buffer.
;Each element of the list is of the form (VALUE START1 END1 START2 END2 ...)
;where VALUE is a `face' property value and STARTx and ENDx are positions."
;  (save-restriction
;    (widen)
;    (let ((start (text-property-not-all (point-min) (point-max) 'face nil))
;	  (limit (point-max)) end properties value cell)
;      (while start
;	(setq end (next-single-property-change start 'face nil limit)
;	      value (get-text-property start 'face))
;	;; Make, or add to existing, list of regions with same `face'.
;	(if (setq cell (assq value properties))
;	    (setcdr cell (cons start (cons end (cdr cell))))
;	  (setq properties (cons (list value start end) properties)))
;	(setq start (next-single-property-change end 'face)))
;      properties)))

(defun fast-lock-get-face-properties ()
  "Return a list of all `face' text properties in the current buffer.
Each element of the list is of the form (VALUE START1 END1 START2 END2 ...)
where VALUE is a `face' property value and STARTx and ENDx are positions.
Only those `face' VALUEs in `fast-lock-save-faces' are returned."
  (save-restriction
    (widen)
    (let ((faces (or fast-lock-save-faces (face-list))) (limit (point-max))
	  properties regions face start end)
      (while faces
	(setq face (car faces) faces (cdr faces) regions () end (point-min))
	;; Make a list of start/end regions with `face' property face.
	(while (setq start (text-property-any end limit 'face face))
	  (setq end (or (text-property-not-all start limit 'face face) limit)
		regions (cons start (cons end regions))))
	;; Add `face' face's regions, if any, to properties.
	(if regions (setq properties (cons (cons face regions) properties))))
      properties)))

(defun fast-lock-set-face-properties (properties)
  "Set all `face' text properties to PROPERTIES in the current buffer.
Any existing `face' text properties are removed first.  Leaves buffer modified.
See `fast-lock-get-face-properties' for the format of PROPERTIES."
  (save-restriction
    (widen)
    (font-lock-unfontify-region (point-min) (point-max))
    (while properties
      (let ((plist (list 'face (car (car properties))))
	    (regions (cdr (car properties))))
	;; Set the `face' property for each start/end region.
	(while regions
	  (set-text-properties (nth 0 regions) (nth 1 regions) plist)
	  (setq regions (nthcdr 2 regions)))
	(setq properties (cdr properties))))))

;; Functions for XEmacs:

(if (save-match-data (string-match "XEmacs" (emacs-version)))
    ;; It would be better to use XEmacs 19.12's `map-extents' over extents with
    ;; `font-lock' property, but `face' properties are on different extents.
    (defun fast-lock-get-face-properties ()
      "Return a list of all `face' text properties in the current buffer.
Each element of the list is of the form (VALUE START1 END1 START2 END2 ...)
where VALUE is a `face' property value and STARTx and ENDx are positions.
Only those `face' VALUEs in `fast-lock-save-faces' are returned."
      (save-restriction
	(widen)
	(let ((properties ()) cell)
	  (map-extents
	   (function
	    (lambda (extent ignore)
	      (let ((value (extent-face extent)))
		;; We're only interested if it's one of `fast-lock-save-faces'.
		(if (and value (or (null fast-lock-save-faces)
				   (memq value fast-lock-save-faces)))
		    (let ((start (extent-start-position extent))
			  (end (extent-end-position extent)))
		      ;; Make or add to existing list of regions with the same
		      ;; `face' property value.
		      (if (setq cell (assq value properties))
			  (setcdr cell (cons start (cons end (cdr cell))))
			(setq properties (cons (list value start end)
					       properties)))))
		;; Return nil to keep `map-extents' going.
		nil))))
	  properties))))

(if (save-match-data (string-match "XEmacs" (emacs-version)))
    ;; Make extents just like XEmacs's font-lock.el does.
    (defun fast-lock-set-face-properties (properties)
      "Set all `face' text properties to PROPERTIES in the current buffer.
Any existing `face' text properties are removed first.
See `fast-lock-get-face-properties' for the format of PROPERTIES."
      (save-restriction
	(widen)
	(font-lock-unfontify-region (point-min) (point-max))
	(while properties
	  (let ((face (car (car properties)))
		(regions (cdr (car properties))))
	    ;; Set the `face' property, etc., for each start/end region.
	    (while regions
	      (font-lock-set-face (nth 0 regions) (nth 1 regions) face)
	      (setq regions (nthcdr 2 regions)))
	    (setq properties (cdr properties)))))))

(or (fboundp 'font-lock-compile-keywords)
    (defalias 'font-lock-compile-keywords 'identity))

;; Install ourselves:

;; We don't install ourselves on `font-lock-mode-hook' as packages with similar
;; functionality exist, and fast-lock.el should be dumpable.
(add-hook 'after-save-hook 'fast-lock-after-save-hook)
(add-hook 'kill-buffer-hook 'fast-lock-kill-buffer-hook)
(add-hook 'kill-emacs-hook 'fast-lock-kill-emacs-hook)

;; Maybe save on the modeline?
;;(setcdr (assq 'font-lock-mode minor-mode-alist) '(" Fast"))

(or (assq 'fast-lock-mode minor-mode-alist)
    (setq minor-mode-alist (cons '(fast-lock-mode " Fast") minor-mode-alist)))

;; Provide ourselves:

(provide 'fast-lock)

;;; fast-lock.el ends here
