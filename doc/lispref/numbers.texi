@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2019 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Numbers
@chapter Numbers
@cindex integers
@cindex numbers

  GNU Emacs supports two numeric data types: @dfn{integers} and
@dfn{floating-point numbers}.  Integers are whole numbers such as
@minus{}3, 0, 7, 13, and 511.  Floating-point numbers are numbers with
fractional parts, such as @minus{}4.5, 0.0, and 2.71828.  They can
also be expressed in exponential notation: @samp{1.5e2} is the same as
@samp{150.0}; here, @samp{e2} stands for ten to the second power, and
that is multiplied by 1.5.  Integer computations are exact.
Floating-point computations often involve rounding errors, as the
numbers have a fixed amount of precision.

@menu
* Integer Basics::            Representation and range of integers.
* Float Basics::              Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Numeric Conversions::       Converting float to integer and vice versa.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Rounding Operations::       Explicitly rounding floating-point numbers.
* Bitwise Operations::        Logical and, or, not, shifting.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.
@end menu

@node Integer Basics
@section Integer Basics

  Integers in Emacs Lisp are not limited to the machine word size.

  Under the hood, though, there are two kinds of integers: smaller
ones, called @dfn{fixnums}, and larger ones, called @dfn{bignums}.
Some functions in Emacs accept only fixnums.  Also, while fixnums can
always be compared for numeric equality with @code{eq}, bignums
require more-heavyweight equality predicates like @code{eql}.

  The range of values for bignums is limited by the amount of main
memory, by machine characteristics such as the size of the word used
to represent a bignum's exponent, and by the @code{integer-width}
variable.  These limits are typically much more generous than the
limits for fixnums.  A bignum is never numerically equal to a fixnum;
if Emacs computes an integer in fixnum range, it represents the
integer as a fixnum, not a bignum.

  The range of values for a fixnum depends on the machine.  The
minimum range is @minus{}536,870,912 to 536,870,911 (30 bits; i.e.,
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
to
@ifnottex
2**29 @minus{} 1),
@end ifnottex
@tex
@math{2^{29}-1}),
@end tex
but many machines provide a wider range.

  The Lisp reader reads an integer as a nonempty sequence
of decimal digits with optional initial sign and optional
final period.

@example
 1               ; @r{The integer 1.}
 1.              ; @r{The integer 1.}
+1               ; @r{Also the integer 1.}
-1               ; @r{The integer @minus{}1.}
 0               ; @r{The integer 0.}
-0               ; @r{The integer 0.}
@end example

@cindex integers in specific radix
@cindex radix for reading an integer
@cindex base for reading an integer
@cindex hex numbers
@cindex octal numbers
@cindex reading numbers in hex, octal, and binary
  The syntax for integers in bases other than 10 consists of @samp{#}
followed by a radix indication followed by one or more digits.  The
radix indications are @samp{b} for binary, @samp{o} for octal,
@samp{x} for hex, and @samp{@var{radix}r} for radix @var{radix}.
Thus, @samp{#b@var{integer}} reads
@var{integer} in binary, and @samp{#@var{radix}r@var{integer}} reads
@var{integer} in radix @var{radix}.  Allowed values of @var{radix} run
from 2 to 36, and allowed digits are the first @var{radix} characters
taken from @samp{0}--@samp{9}, @samp{A}--@samp{Z}.
Letter case is ignored and there is no initial sign or final period.
For example:

@example
#b101100 @result{} 44
#o54 @result{} 44
#x2c @result{} 44
#24r1k @result{} 44
@end example

  To understand how various functions work on integers, especially the
bitwise operators (@pxref{Bitwise Operations}), it is often helpful to
view the numbers in their binary form.

  In binary, the decimal integer 5 looks like this:

@example
@dots{}000101
@end example

@noindent
(The ellipsis @samp{@dots{}} stands for a conceptually infinite number
of bits that match the leading bit; here, an infinite number of 0
bits.  Later examples also use this @samp{@dots{}} notation.)

  The integer @minus{}1 looks like this:

@example
@dots{}111111
@end example

@noindent
@cindex two's complement
@minus{}1 is represented as all ones.  (This is called @dfn{two's
complement} notation.)

  Subtracting 4 from @minus{}1 returns the negative integer @minus{}5.
In binary, the decimal integer 4 is 100.  Consequently,
@minus{}5 looks like this:

@example
@dots{}111011
@end example

  Many of the functions described in this chapter accept markers for
arguments in place of numbers.  (@xref{Markers}.)  Since the actual
arguments to such functions may be either numbers or markers, we often
give these arguments the name @var{number-or-marker}.  When the argument
value is a marker, its position value is used and its buffer is ignored.

@cindex largest fixnum
@cindex maximum fixnum
@defvar most-positive-fixnum
The value of this variable is the greatest ``small'' integer that Emacs
Lisp can handle.  Typical values are
@ifnottex
2**29 @minus{} 1
@end ifnottex
@tex
@math{2^{29}-1}
@end tex
on 32-bit and
@ifnottex
2**61 @minus{} 1
@end ifnottex
@tex
@math{2^{61}-1}
@end tex
on 64-bit platforms.
@end defvar

@cindex smallest fixnum
@cindex minimum fixnum
@defvar most-negative-fixnum
The value of this variable is the numerically least ``small'' integer
that Emacs Lisp can handle.  It is negative.  Typical values are
@ifnottex
@minus{}2**29
@end ifnottex
@tex
@math{-2^{29}}
@end tex
on 32-bit and
@ifnottex
@minus{}2**61
@end ifnottex
@tex
@math{-2^{61}}
@end tex
on 64-bit platforms.
@end defvar

@cindex bignum range
@cindex integer range
@cindex number of bignum bits, limit on
@defvar integer-width
The value of this variable is a nonnegative integer that controls
whether Emacs signals a range error when a large integer would be
calculated.  Integers with absolute values less than
@ifnottex
2**@var{n},
@end ifnottex
@tex
@math{2^{n}},
@end tex
where @var{n} is this variable's value, do not signal a range error.
Attempts to create larger integers typically signal a range error,
although there might be no signal if a larger integer can be created cheaply.
Setting this variable to a large number can be costly if a computation
creates huge integers.
@end defvar

  In Emacs Lisp, text characters are represented by integers.  Any
integer between zero and the value of @code{(max-char)}, inclusive, is
considered to be valid as a character.  @xref{Character Codes}.

@node Float Basics
@section Floating-Point Basics

@cindex @acronym{IEEE} floating point
  Floating-point numbers are useful for representing numbers that are
not integral.  The range of floating-point numbers is
the same as the range of the C data type @code{double} on the machine
you are using.  On all computers currently supported by Emacs, this is
double-precision @acronym{IEEE} floating point.

  The read syntax for floating-point numbers requires either a decimal
point, an exponent, or both.  Optional signs (@samp{+} or @samp{-})
precede the number and its exponent.  For example, @samp{1500.0},
@samp{+15e2}, @samp{15.0e+2}, @samp{+1500000e-3}, and @samp{.15e4} are
five ways of writing a floating-point number whose value is 1500.
They are all equivalent.  Like Common Lisp, Emacs Lisp requires at
least one digit after any decimal point in a floating-point number;
@samp{1500.} is an integer, not a floating-point number.

  Emacs Lisp treats @code{-0.0} as numerically equal to ordinary zero
with respect to numeric comparisons like @code{=}.  This follows the
@acronym{IEEE} floating-point standard, which says @code{-0.0} and
@code{0.0} are numerically equal even though other operations can
distinguish them.

@cindex positive infinity
@cindex negative infinity
@cindex infinity
@cindex NaN
  The @acronym{IEEE} floating-point standard supports positive
infinity and negative infinity as floating-point values.  It also
provides for a class of values called NaN, or ``not a number'';
numerical functions return such values in cases where there is no
correct answer.  For example, @code{(/ 0.0 0.0)} returns a NaN@.
A NaN is never numerically equal to any value, not even to itself.
NaNs carry a sign and a significand, and non-numeric functions treat
two NaNs as equal when their
signs and significands agree.  Significands of NaNs are
machine-dependent, as are the digits in their string representation.

  When NaNs and signed zeros are involved, non-numeric functions like
@code{eql}, @code{equal}, @code{sxhash-eql}, @code{sxhash-equal} and
@code{gethash} determine whether values are indistinguishable, not
whether they are numerically equal.  For example, when @var{x} and
@var{y} are the same NaN, @code{(equal x y)} returns @code{t} whereas
@code{(= x y)} uses numeric comparison and returns @code{nil};
conversely, @code{(equal 0.0 -0.0)} returns @code{nil} whereas
@code{(= 0.0 -0.0)} returns @code{t}.

Here are read syntaxes for these special floating-point values:

@table @asis
@item infinity
@samp{1.0e+INF} and @samp{-1.0e+INF}
@item not-a-number
@samp{0.0e+NaN} and @samp{-0.0e+NaN}
@end table

  The following functions are specialized for handling floating-point
numbers:

@defun isnan x
This predicate returns @code{t} if its floating-point argument is a NaN,
@code{nil} otherwise.
@end defun

@defun frexp x
This function returns a cons cell @code{(@var{s} . @var{e})},
where @var{s} and @var{e} are respectively the significand and
exponent of the floating-point number @var{x}.

If @var{x} is finite, then @var{s} is a floating-point number between 0.5
(inclusive) and 1.0 (exclusive), @var{e} is an integer, and
@ifnottex
@var{x} = @var{s} * 2**@var{e}.
@end ifnottex
@tex
@math{x = s 2^e}.
@end tex
If @var{x} is zero or infinity, then @var{s} is the same as @var{x}.
If @var{x} is a NaN, then @var{s} is also a NaN@.
If @var{x} is zero, then @var{e} is 0.
@end defun

@defun ldexp s e
Given a numeric significand @var{s} and an integer exponent @var{e},
this function returns the floating point number
@ifnottex
@var{s} * 2**@var{e}.
@end ifnottex
@tex
@math{s 2^e}.
@end tex
@end defun

@defun copysign x1 x2
This function copies the sign of @var{x2} to the value of @var{x1},
and returns the result.  @var{x1} and @var{x2} must be floating point.
@end defun

@defun logb x
This function returns the binary exponent of @var{x}.  More
precisely, if @var{x} is finite and nonzero, the value is the
logarithm base 2 of @math{|x|}, rounded down to an integer.
If @var{x} is zero, infinite, or a NaN, the value is minus infinity,
plus infinity, or a NaN respectively.

@example
(logb 10)
     @result{} 3
(logb 10.0e20)
     @result{} 69
(logb 0)
     @result{} -1.0e+INF
@end example
@end defun

@node Predicates on Numbers
@section Type Predicates for Numbers
@cindex predicates for numbers

  The functions in this section test for numbers, or for a specific
type of number.  The functions @code{integerp} and @code{floatp} can
take any type of Lisp object as argument (they would not be of much
use otherwise), but the @code{zerop} predicate requires a number as
its argument.  See also @code{integer-or-marker-p} and
@code{number-or-marker-p}, in @ref{Predicates on Markers}.

@defun bignump object
This predicate tests whether its argument is a large integer, and
returns @code{t} if so, @code{nil} otherwise.  Unlike small integers,
large integers can be @code{=} or @code{eql} even if they are not @code{eq}.
@end defun

@defun fixnump object
This predicate tests whether its argument is a small integer, and
returns @code{t} if so, @code{nil} otherwise.  Small integers can be
compared with @code{eq}.
@end defun

@defun floatp object
This predicate tests whether its argument is floating point
and returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun integerp object
This predicate tests whether its argument is an integer, and returns
@code{t} if so, @code{nil} otherwise.
@end defun

@defun numberp object
This predicate tests whether its argument is a number (either integer or
floating point), and returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun natnump object
@cindex natural numbers
This predicate (whose name comes from the phrase ``natural number'')
tests to see whether its argument is a nonnegative integer, and
returns @code{t} if so, @code{nil} otherwise.  0 is considered
non-negative.

@findex wholenump
@code{wholenump} is a synonym for @code{natnump}.
@end defun

@defun zerop number
This predicate tests whether its argument is zero, and returns @code{t}
if so, @code{nil} otherwise.  The argument must be a number.

@code{(zerop x)} is equivalent to @code{(= x 0)}.
@end defun

@node Comparison of Numbers
@section Comparison of Numbers
@cindex number comparison
@cindex comparing numbers

  To test numbers for numerical equality, you should normally use
@code{=} instead of non-numeric comparison predicates like @code{eq},
@code{eql} and @code{equal}.  Distinct floating-point and large
integer objects can be numerically equal.  If you use @code{eq} to
compare them, you test whether they are the same @emph{object}; if you
use @code{eql} or @code{equal}, you test whether their values are
@emph{indistinguishable}.  In contrast, @code{=} uses numeric
comparison, and sometimes returns @code{t} when a non-numeric
comparison would return @code{nil} and vice versa.  @xref{Float
Basics}.

  In Emacs Lisp, if two fixnums are numerically equal, they are the
same Lisp object.  That is, @code{eq} is equivalent to @code{=} on
fixnums.  It is sometimes convenient to use @code{eq} for comparing
an unknown value with a fixnum, because @code{eq} does not report an
error if the unknown value is not a number---it accepts arguments of
any type.  By contrast, @code{=} signals an error if the arguments are
not numbers or markers.  However, it is better programming practice to
use @code{=} if you can, even for comparing integers.

  Sometimes it is useful to compare numbers with @code{eql} or @code{equal},
which treat two numbers as equal if they have the same data type (both
integers, or both floating point) and the same value.  By contrast,
@code{=} can treat an integer and a floating-point number as equal.
@xref{Equality Predicates}.

  There is another wrinkle: because floating-point arithmetic is not
exact, it is often a bad idea to check for equality of floating-point
values.  Usually it is better to test for approximate equality.
Here's a function to do this:

@example
(defvar fuzz-factor 1.0e-6)
(defun approx-equal (x y)
  (or (= x y)
      (< (/ (abs (- x y))
            (max (abs x) (abs y)))
         fuzz-factor)))
@end example

@defun = number-or-marker &rest number-or-markers
This function tests whether all its arguments are numerically equal,
and returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun eql value1 value2
This function acts like @code{eq} except when both arguments are
numbers.  It compares numbers by type and numeric value, so that
@code{(eql 1.0 1)} returns @code{nil}, but @code{(eql 1.0 1.0)} and
@code{(eql 1 1)} both return @code{t}.  This can be used to compare
large integers as well as small ones.
@end defun

@defun /= number-or-marker1 number-or-marker2
This function tests whether its arguments are numerically equal, and
returns @code{t} if they are not, and @code{nil} if they are.
@end defun

@defun <  number-or-marker &rest number-or-markers
This function tests whether each argument is strictly less than the
following argument.  It returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun <= number-or-marker &rest number-or-markers
This function tests whether each argument is less than or equal to
the following argument.  It returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun > number-or-marker &rest number-or-markers
This function tests whether each argument is strictly greater than
the following argument.  It returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun >= number-or-marker &rest number-or-markers
This function tests whether each argument is greater than or equal to
the following argument.  It returns @code{t} if so, @code{nil} otherwise.
@end defun

@defun max number-or-marker &rest numbers-or-markers
This function returns the largest of its arguments.

@example
(max 20)
     @result{} 20
(max 1 2.5)
     @result{} 2.5
(max 1 3 2.5)
     @result{} 3
@end example
@end defun

@defun min number-or-marker &rest numbers-or-markers
This function returns the smallest of its arguments.

@example
(min -4 1)
     @result{} -4
@end example
@end defun

@defun abs number
This function returns the absolute value of @var{number}.
@end defun

@node Numeric Conversions
@section Numeric Conversions
@cindex rounding in conversions
@cindex number conversions
@cindex converting numbers

To convert an integer to floating point, use the function @code{float}.

@defun float number
This returns @var{number} converted to floating point.
If @var{number} is already floating point, @code{float} returns
it unchanged.
@end defun

  There are four functions to convert floating-point numbers to
integers; they differ in how they round.  All accept an argument
@var{number} and an optional argument @var{divisor}.  Both arguments
may be integers or floating-point numbers.  @var{divisor} may also be
@code{nil}.  If @var{divisor} is @code{nil} or omitted, these
functions convert @var{number} to an integer, or return it unchanged
if it already is an integer.  If @var{divisor} is non-@code{nil}, they
divide @var{number} by @var{divisor} and convert the result to an
integer.  If @var{divisor} is zero (whether integer or
floating point), Emacs signals an @code{arith-error} error.

@defun truncate number &optional divisor
This returns @var{number}, converted to an integer by rounding towards
zero.

@example
(truncate 1.2)
     @result{} 1
(truncate 1.7)
     @result{} 1
(truncate -1.2)
     @result{} -1
(truncate -1.7)
     @result{} -1
@end example
@end defun

@defun floor number &optional divisor
This returns @var{number}, converted to an integer by rounding downward
(towards negative infinity).

If @var{divisor} is specified, this uses the kind of division
operation that corresponds to @code{mod}, rounding downward.

@example
(floor 1.2)
     @result{} 1
(floor 1.7)
     @result{} 1
(floor -1.2)
     @result{} -2
(floor -1.7)
     @result{} -2
(floor 5.99 3)
     @result{} 1
@end example
@end defun

@defun ceiling number &optional divisor
This returns @var{number}, converted to an integer by rounding upward
(towards positive infinity).

@example
(ceiling 1.2)
     @result{} 2
(ceiling 1.7)
     @result{} 2
(ceiling -1.2)
     @result{} -1
(ceiling -1.7)
     @result{} -1
@end example
@end defun

@defun round number &optional divisor
This returns @var{number}, converted to an integer by rounding towards the
nearest integer.  Rounding a value equidistant between two integers
returns the even integer.

@example
(round 1.2)
     @result{} 1
(round 1.7)
     @result{} 2
(round -1.2)
     @result{} -1
(round -1.7)
     @result{} -2
@end example
@end defun

@node Arithmetic Operations
@section Arithmetic Operations
@cindex arithmetic operations

  Emacs Lisp provides the traditional four arithmetic operations
(addition, subtraction, multiplication, and division), as well as
remainder and modulus functions, and functions to add or subtract 1.
Except for @code{%}, each of these functions accepts both integer and
floating-point arguments, and returns a floating-point number if any
argument is floating point.

@defun 1+ number-or-marker
This function returns @var{number-or-marker} plus 1.
For example,

@example
(setq foo 4)
     @result{} 4
(1+ foo)
     @result{} 5
@end example

This function is not analogous to the C operator @code{++}---it does not
increment a variable.  It just computes a sum.  Thus, if we continue,

@example
foo
     @result{} 4
@end example

If you want to increment the variable, you must use @code{setq},
like this:

@example
(setq foo (1+ foo))
     @result{} 5
@end example
@end defun

@defun 1- number-or-marker
This function returns @var{number-or-marker} minus 1.
@end defun

@defun + &rest numbers-or-markers
This function adds its arguments together.  When given no arguments,
@code{+} returns 0.

@example
(+)
     @result{} 0
(+ 1)
     @result{} 1
(+ 1 2 3 4)
     @result{} 10
@end example
@end defun

@defun - &optional number-or-marker &rest more-numbers-or-markers
The @code{-} function serves two purposes: negation and subtraction.
When @code{-} has a single argument, the value is the negative of the
argument.  When there are multiple arguments, @code{-} subtracts each of
the @var{more-numbers-or-markers} from @var{number-or-marker},
cumulatively.  If there are no arguments, the result is 0.

@example
(- 10 1 2 3 4)
     @result{} 0
(- 10)
     @result{} -10
(-)
     @result{} 0
@end example
@end defun

@defun * &rest numbers-or-markers
This function multiplies its arguments together, and returns the
product.  When given no arguments, @code{*} returns 1.

@example
(*)
     @result{} 1
(* 1)
     @result{} 1
(* 1 2 3 4)
     @result{} 24
@end example
@end defun

@defun / number &rest divisors
With one or more @var{divisors}, this function divides @var{number}
by each divisor in @var{divisors} in turn, and returns the quotient.
With no @var{divisors}, this function returns 1/@var{number}, i.e.,
the multiplicative inverse of @var{number}.  Each argument may be a
number or a marker.

If all the arguments are integers, the result is an integer, obtained
by rounding the quotient towards zero after each division.

@example
@group
(/ 6 2)
     @result{} 3
@end group
@group
(/ 5 2)
     @result{} 2
@end group
@group
(/ 5.0 2)
     @result{} 2.5
@end group
@group
(/ 5 2.0)
     @result{} 2.5
@end group
@group
(/ 5.0 2.0)
     @result{} 2.5
@end group
@group
(/ 4.0)
     @result{} 0.25
@end group
@group
(/ 4)
     @result{} 0
@end group
@group
(/ 25 3 2)
     @result{} 4
@end group
@group
(/ -17 6)
     @result{} -2
@end group
@end example

@cindex @code{arith-error} in division
If you divide an integer by the integer 0, Emacs signals an
@code{arith-error} error (@pxref{Errors}).  Floating-point division of
a nonzero number by zero yields either positive or negative infinity
(@pxref{Float Basics}).
@end defun

@defun % dividend divisor
@cindex remainder
This function returns the integer remainder after division of @var{dividend}
by @var{divisor}.  The arguments must be integers or markers.

For any two integers @var{dividend} and @var{divisor},

@example
@group
(+ (% @var{dividend} @var{divisor})
   (* (/ @var{dividend} @var{divisor}) @var{divisor}))
@end group
@end example

@noindent
always equals @var{dividend} if @var{divisor} is nonzero.

@example
(% 9 4)
     @result{} 1
(% -9 4)
     @result{} -1
(% 9 -4)
     @result{} 1
(% -9 -4)
     @result{} -1
@end example
@end defun

@defun mod dividend divisor
@cindex modulus
This function returns the value of @var{dividend} modulo @var{divisor};
in other words, the remainder after division of @var{dividend}
by @var{divisor}, but with the same sign as @var{divisor}.
The arguments must be numbers or markers.

Unlike @code{%}, @code{mod} permits floating-point arguments; it
rounds the quotient downward (towards minus infinity) to an integer,
and uses that quotient to compute the remainder.

If @var{divisor} is zero, @code{mod} signals an @code{arith-error}
error if both arguments are integers, and returns a NaN otherwise.

@example
@group
(mod 9 4)
     @result{} 1
@end group
@group
(mod -9 4)
     @result{} 3
@end group
@group
(mod 9 -4)
     @result{} -3
@end group
@group
(mod -9 -4)
     @result{} -1
@end group
@group
(mod 5.5 2.5)
     @result{} .5
@end group
@end example

For any two numbers @var{dividend} and @var{divisor},

@example
@group
(+ (mod @var{dividend} @var{divisor})
   (* (floor @var{dividend} @var{divisor}) @var{divisor}))
@end group
@end example

@noindent
always equals @var{dividend}, subject to rounding error if either
argument is floating point and to an @code{arith-error} if @var{dividend} is an
integer and @var{divisor} is 0.  For @code{floor}, see @ref{Numeric
Conversions}.
@end defun

@node Rounding Operations
@section Rounding Operations
@cindex rounding without conversion

The functions @code{ffloor}, @code{fceiling}, @code{fround}, and
@code{ftruncate} take a floating-point argument and return a floating-point
result whose value is a nearby integer.  @code{ffloor} returns the
nearest integer below; @code{fceiling}, the nearest integer above;
@code{ftruncate}, the nearest integer in the direction towards zero;
@code{fround}, the nearest integer.

@defun ffloor float
This function rounds @var{float} to the next lower integral value, and
returns that value as a floating-point number.
@end defun

@defun fceiling float
This function rounds @var{float} to the next higher integral value, and
returns that value as a floating-point number.
@end defun

@defun ftruncate float
This function rounds @var{float} towards zero to an integral value, and
returns that value as a floating-point number.
@end defun

@defun fround float
This function rounds @var{float} to the nearest integral value,
and returns that value as a floating-point number.
Rounding a value equidistant between two integers returns the even integer.
@end defun

@node Bitwise Operations
@section Bitwise Operations on Integers
@cindex bitwise arithmetic
@cindex logical arithmetic

  In a computer, an integer is represented as a binary number, a
sequence of @dfn{bits} (digits which are either zero or one).
Conceptually the bit sequence is infinite on the left, with the
most-significant bits being all zeros or all ones.  A bitwise
operation acts on the individual bits of such a sequence.  For example,
@dfn{shifting} moves the whole sequence left or right one or more places,
reproducing the same pattern moved over.

  The bitwise operations in Emacs Lisp apply only to integers.

@defun ash integer1 count
@cindex arithmetic shift
@code{ash} (@dfn{arithmetic shift}) shifts the bits in @var{integer1}
to the left @var{count} places, or to the right if @var{count} is
negative.  Left shifts introduce zero bits on the right; right shifts
discard the rightmost bits.  Considered as an integer operation,
@code{ash} multiplies @var{integer1} by
@ifnottex
2**@var{count},
@end ifnottex
@tex
@math{2^{count}},
@end tex
and then converts the result to an integer by rounding downward, toward
minus infinity.

Here are examples of @code{ash}, shifting a pattern of bits one place
to the left and to the right.  These examples show only the low-order
bits of the binary pattern; leading bits all agree with the
highest-order bit shown.  As you can see, shifting left by one is
equivalent to multiplying by two, whereas shifting right by one is
equivalent to dividing by two and then rounding toward minus infinity.

@example
@group
(ash 7 1) @result{} 14
;; @r{Decimal 7 becomes decimal 14.}
@dots{}000111
     @result{}
@dots{}001110
@end group

@group
(ash 7 -1) @result{} 3
@dots{}000111
     @result{}
@dots{}000011
@end group

@group
(ash -7 1) @result{} -14
@dots{}111001
     @result{}
@dots{}110010
@end group

@group
(ash -7 -1) @result{} -4
@dots{}111001
     @result{}
@dots{}111100
@end group
@end example

Here are examples of shifting left or right by two bits:

@smallexample
@group
                  ;  @r{       binary values}
(ash 5 2)         ;   5  =  @r{@dots{}000101}
     @result{} 20         ;      =  @r{@dots{}010100}
(ash -5 2)        ;  -5  =  @r{@dots{}111011}
     @result{} -20        ;      =  @r{@dots{}101100}
@end group
@group
(ash 5 -2)
     @result{} 1          ;      =  @r{@dots{}000001}
@end group
@group
(ash -5 -2)
     @result{} -2         ;      =  @r{@dots{}111110}
@end group
@end smallexample
@end defun

@defun lsh integer1 count
@cindex logical shift
@code{lsh}, which is an abbreviation for @dfn{logical shift}, shifts the
bits in @var{integer1} to the left @var{count} places, or to the right
if @var{count} is negative, bringing zeros into the vacated bits.  If
@var{count} is negative, then @var{integer1} must be either a fixnum
or a positive bignum, and @code{lsh} treats a negative fixnum as if it
were unsigned by subtracting twice @code{most-negative-fixnum} before
shifting, producing a nonnegative result.  This quirky behavior dates
back to when Emacs supported only fixnums; nowadays @code{ash} is a
better choice.

As @code{lsh} behaves like @code{ash} except when @var{integer1} and
@var{count1} are both negative, the following examples focus on these
exceptional cases.  These examples assume 30-bit fixnums.

@smallexample
@group
                 ; @r{     binary values}
(ash -7 -1)      ; -7 = @r{@dots{}111111111111111111111111111001}
     @result{} -4        ;    = @r{@dots{}111111111111111111111111111100}
(lsh -7 -1)
     @result{} 536870908 ;    = @r{@dots{}011111111111111111111111111100}
@end group
@group
(ash -5 -2)      ; -5 = @r{@dots{}111111111111111111111111111011}
     @result{} -2        ;    = @r{@dots{}111111111111111111111111111110}
(lsh -5 -2)
     @result{} 268435454 ;    = @r{@dots{}001111111111111111111111111110}
@end group
@end smallexample
@end defun

@defun logand &rest ints-or-markers
This function returns the bitwise AND of the arguments: the @var{n}th
bit is 1 in the result if, and only if, the @var{n}th bit is 1 in all
the arguments.

For example, using 4-bit binary numbers, the bitwise AND of 13 and
12 is 12: 1101 combined with 1100 produces 1100.
In both the binary numbers, the leftmost two bits are both 1
so the leftmost two bits of the returned value are both 1.
However, for the rightmost two bits, each is 0 in at least one of
the arguments, so the rightmost two bits of the returned value are both 0.

@noindent
Therefore,

@example
@group
(logand 13 12)
     @result{} 12
@end group
@end example

If @code{logand} is not passed any argument, it returns a value of
@minus{}1.  This number is an identity element for @code{logand}
because its binary representation consists entirely of ones.  If
@code{logand} is passed just one argument, it returns that argument.

@smallexample
@group
                   ; @r{       binary values}

(logand 14 13)     ; 14  =  @r{@dots{}001110}
                   ; 13  =  @r{@dots{}001101}
     @result{} 12         ; 12  =  @r{@dots{}001100}
@end group

@group
(logand 14 13 4)   ; 14  =  @r{@dots{}001110}
                   ; 13  =  @r{@dots{}001101}
                   ;  4  =  @r{@dots{}000100}
     @result{} 4          ;  4  =  @r{@dots{}000100}
@end group

@group
(logand)
     @result{} -1         ; -1  =  @r{@dots{}111111}
@end group
@end smallexample
@end defun

@defun logior &rest ints-or-markers
This function returns the bitwise inclusive OR of its arguments: the @var{n}th
bit is 1 in the result if, and only if, the @var{n}th bit is 1 in at
least one of the arguments.  If there are no arguments, the result is 0,
which is an identity element for this operation.  If @code{logior} is
passed just one argument, it returns that argument.

@smallexample
@group
                   ; @r{       binary values}

(logior 12 5)      ; 12  =  @r{@dots{}001100}
                   ;  5  =  @r{@dots{}000101}
     @result{} 13         ; 13  =  @r{@dots{}001101}
@end group

@group
(logior 12 5 7)    ; 12  =  @r{@dots{}001100}
                   ;  5  =  @r{@dots{}000101}
                   ;  7  =  @r{@dots{}000111}
     @result{} 15         ; 15  =  @r{@dots{}001111}
@end group
@end smallexample
@end defun

@defun logxor &rest ints-or-markers
This function returns the bitwise exclusive OR of its arguments: the
@var{n}th bit is 1 in the result if, and only if, the @var{n}th bit is
1 in an odd number of the arguments.  If there are no arguments, the
result is 0, which is an identity element for this operation.  If
@code{logxor} is passed just one argument, it returns that argument.

@smallexample
@group
                   ; @r{       binary values}

(logxor 12 5)      ; 12  =  @r{@dots{}001100}
                   ;  5  =  @r{@dots{}000101}
     @result{} 9          ;  9  =  @r{@dots{}001001}
@end group

@group
(logxor 12 5 7)    ; 12  =  @r{@dots{}001100}
                   ;  5  =  @r{@dots{}000101}
                   ;  7  =  @r{@dots{}000111}
     @result{} 14         ; 14  =  @r{@dots{}001110}
@end group
@end smallexample
@end defun

@defun lognot integer
This function returns the bitwise complement of its argument: the @var{n}th
bit is one in the result if, and only if, the @var{n}th bit is zero in
@var{integer}, and vice-versa.  The result equals @minus{}1 @minus{}
@var{integer}.

@example
(lognot 5)
     @result{} -6
;;  5  =  @r{@dots{}000101}
;; @r{becomes}
;; -6  =  @r{@dots{}111010}
@end example
@end defun

@cindex popcount
@cindex Hamming weight
@cindex counting set bits
@defun logcount integer
This function returns the @dfn{Hamming weight} of @var{integer}: the
number of ones in the binary representation of @var{integer}.
If @var{integer} is negative, it returns the number of zero bits in
its two's complement binary representation.  The result is always
nonnegative.

@example
(logcount 43)     ;  43 = @r{@dots{}000101011}
     @result{} 4
(logcount -43)    ; -43 = @r{@dots{}111010101}
     @result{} 3
@end example
@end defun

@node Math Functions
@section Standard Mathematical Functions
@cindex transcendental functions
@cindex mathematical functions
@cindex floating-point functions

  These mathematical functions allow integers as well as floating-point
numbers as arguments.

@defun sin arg
@defunx cos arg
@defunx tan arg
These are the basic trigonometric functions, with argument @var{arg}
measured in radians.
@end defun

@defun asin arg
The value of @code{(asin @var{arg})} is a number between
@ifnottex
@minus{}pi/2
@end ifnottex
@tex
@math{-\pi/2}
@end tex
and
@ifnottex
pi/2
@end ifnottex
@tex
@math{\pi/2}
@end tex
(inclusive) whose sine is @var{arg}.  If @var{arg} is out of range
(outside [@minus{}1, 1]), @code{asin} returns a NaN.
@end defun

@defun acos arg
The value of @code{(acos @var{arg})} is a number between 0 and
@ifnottex
pi
@end ifnottex
@tex
@math{\pi}
@end tex
(inclusive) whose cosine is @var{arg}.  If @var{arg} is out of range
(outside [@minus{}1, 1]), @code{acos} returns a NaN.
@end defun

@defun atan y &optional x
The value of @code{(atan @var{y})} is a number between
@ifnottex
@minus{}pi/2
@end ifnottex
@tex
@math{-\pi/2}
@end tex
and
@ifnottex
pi/2
@end ifnottex
@tex
@math{\pi/2}
@end tex
(exclusive) whose tangent is @var{y}.  If the optional second
argument @var{x} is given, the value of @code{(atan y x)} is the
angle in radians between the vector @code{[@var{x}, @var{y}]} and the
@code{X} axis.
@end defun

@defun exp arg
This is the exponential function; it returns @math{e} to the power
@var{arg}.
@end defun

@defun log arg &optional base
This function returns the logarithm of @var{arg}, with base
@var{base}.  If you don't specify @var{base}, the natural base
@math{e} is used.  If @var{arg} or @var{base} is negative, @code{log}
returns a NaN.
@end defun

@defun expt x y
This function returns @var{x} raised to power @var{y}.  If both
arguments are integers and @var{y} is nonnegative, the result is an
integer; in this case, overflow signals an error, so watch out.
If @var{x} is a finite negative number and @var{y} is a finite
non-integer, @code{expt} returns a NaN.
@end defun

@defun sqrt arg
This returns the square root of @var{arg}.  If @var{arg} is finite
and less than zero, @code{sqrt} returns a NaN.
@end defun

In addition, Emacs defines the following common mathematical
constants:

@defvar float-e
The mathematical constant @math{e} (2.71828@dots{}).
@end defvar

@defvar float-pi
The mathematical constant @math{pi} (3.14159@dots{}).
@end defvar

@node Random Numbers
@section Random Numbers
@cindex random numbers

  A deterministic computer program cannot generate true random
numbers.  For most purposes, @dfn{pseudo-random numbers} suffice.  A
series of pseudo-random numbers is generated in a deterministic
fashion.  The numbers are not truly random, but they have certain
properties that mimic a random series.  For example, all possible
values occur equally often in a pseudo-random series.

@cindex seed, for random number generation
  Pseudo-random numbers are generated from a @dfn{seed value}.  Starting from
any given seed, the @code{random} function always generates the same
sequence of numbers.  By default, Emacs initializes the random seed at
startup, in such a way that the sequence of values of @code{random}
(with overwhelming likelihood) differs in each Emacs run.

  Sometimes you want the random number sequence to be repeatable.  For
example, when debugging a program whose behavior depends on the random
number sequence, it is helpful to get the same behavior in each
program run.  To make the sequence repeat, execute @code{(random "")}.
This sets the seed to a constant value for your particular Emacs
executable (though it may differ for other Emacs builds).  You can use
other strings to choose various seed values.

@defun random &optional limit
This function returns a pseudo-random integer.  Repeated calls return a
series of pseudo-random integers.

If @var{limit} is a positive fixnum, the value is chosen to be
nonnegative and less than @var{limit}.  Otherwise, the value might be
any fixnum, i.e., any integer from @code{most-negative-fixnum} through
@code{most-positive-fixnum} (@pxref{Integer Basics}).

If @var{limit} is @code{t}, it means to choose a new seed as if Emacs
were restarting, typically from the system entropy.  On systems
lacking entropy pools, choose the seed from less-random volatile data
such as the current time.

If @var{limit} is a string, it means to choose a new seed based on the
string's contents.

@end defun
